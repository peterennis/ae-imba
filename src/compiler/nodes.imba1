# imba$inlineHelpers=1
# imba$v2=0
# TODO Create Expression - make all expressions inherit from these?

var helpers = require './helpers'
var constants = require './constants'
var csscompiler = require './css'

import ImbaParseError from './errors'
import Token from './token'
import SourceMap from './sourcemap'

var TAG_NAMES = constants.TAG_NAMES

var TAG_TYPES = {}
var TAG_ATTRS = {}

TAG_TYPES.HTML = "a abbr address area article aside audio b base bdi bdo big blockquote body br
 button canvas caption cite code col colgroup data datalist dd del details dfn
 div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6
 head header hr html i iframe img input ins kbd keygen label legend li link
 main map mark menu menuitem meta meter nav noscript object ol optgroup option
 output p param pre progress q rp rt ruby s samp script section select small
 source span strong style sub summary sup table tbody td textarea tfoot th
 thead time title tr track u ul var video wbr".split(" ")

TAG_TYPES.SVG = "circle defs ellipse g line linearGradient mask path pattern polygon polyline
radialGradient rect stop svg text tspan".split(" ")

TAG_ATTRS.HTML = "accept accessKey action allowFullScreen allowTransparency alt async
 autoComplete autoFocus autoPlay cellPadding cellSpacing charSet checked
 className cols colSpan content contentEditable contextMenu controls coords
 crossOrigin data dateTime defer dir disabled download draggable encType form
 formNoValidate frameBorder height hidden href hrefLang htmlFor httpEquiv icon
 id label lang list loop max maxLength mediaGroup method min multiple muted
 name noValidate pattern placeholder poster preload radioGroup readOnly rel
 required role rows rowSpan sandbox scope scrollLeft scrolling scrollTop
 seamless selected shape size span spellCheck src srcDoc srcSet start step
 style tabIndex target title type useMap value width wmode"

TAG_ATTRS.SVG = "cx cy d dx dy fill fillOpacity fontFamily fontSize fx fy gradientTransform
 gradientUnits markerEnd markerMid markerStart offset opacity
 patternContentUnits patternUnits points preserveAspectRatio r rx ry
 spreadMethod stopColor stopOpacity stroke strokeDasharray strokeLinecap
 strokeOpacity strokeWidth textAnchor transform version viewBox x1 x2 x y1 y2 y"

var CUSTOM_EVENTS = {
	intersect: yes
	selection: yes
}

export var AST = {}

var TREE_TYPE =
	DYNAMIC: 1
	STATIC: 2
	SINGLE: 3
	OPTLOOP: 4
	LOOP: 5

export var F = 
	TAG_INITED: 2 ** 0 
	TAG_BUILT: 2 ** 1 # available
	TAG_CUSTOM: 2 ** 2 # available
	TAG_AWAKENED: 2 ** 3
	TAG_MOUNTED: 2 ** 4
	TAG_SCHEDULE: 2 ** 5 # available
	TAG_SCHEDULED: 2 ** 6
	TAG_FIRST_CHILD: 2 ** 7
	TAG_LAST_CHILD: 2 ** 8
	TAG_HAS_DYNAMIC_FLAGS: 2 ** 9
	TAG_HAS_BRANCHES: 2 ** 10
	TAG_HAS_LOOPS: 2 ** 11
	TAG_HAS_DYNAMIC_CHILDREN: 2 ** 12
	TAG_IN_BRANCH: 2 ** 13
	TAG_BIND_MODEL: 2 ** 14
	TAG_INDEXED: 2 ** 15 # not used
	TAG_KEYED: 2 ** 16 # not used

	# render marks
	DIFF_BUILT: 2 ** 0
	DIFF_FLAGS: 2 ** 1
	DIFF_ATTRS: 2 ** 2
	DIFF_CHILDREN: 2 ** 3


# Helpers for operators
export var OP = do |op, l, r|
	var o = String(op)
	if o == '-' and !r and l isa Num
		l.@value = -l.toNumber
		return l
	elif o == '+' and !r and l isa Num
		return l

	switch o
		when '.'
			r = Identifier.new(r) if r isa String
			# r = r.value if r isa VarOrAccess
			Access.new(op,l,r)
		when '='
			Assign.new(op,l,r)

		when '?=','||=','&&='
			ConditionalAssign.new(op,l,r)
		when '+=','-=','*=','/=','^=','%=','**='
			CompoundAssign.new(op,l,r)

		when '?.'
			if r isa VarOrAccess
				r = r.value

			# depends on the right side - this is wrong
			PropertyAccess.new(op,l,r)

		when 'instanceof','isa'
			InstanceOf.new(op,l,r)
		when 'in'
			In.new(op,l,r)
		when 'typeof'
			TypeOf.new(op,l,r)
		when 'delete'
			Delete.new(op,l,r)
		when '--','++','!','âˆš','not' # alias
			UnaryOp.new(op,l,r)
		when '>','<','>=','<=','==','===','!=','!=='
			ComparisonOp.new(op,l,r)
		when '..','...'
			Range.new(op,l,r)
		else
			Op.new(op,l,r)

export var OP_COMPOUND = do |sym,op,l,r|
	# console.log "?. soak operator",sym
	if sym == '?.'
		console.log "?. soak operator"
		return null
	if sym == '?=' or sym == '||=' or sym == '&&='
		return ConditionalAssign.new(op,l,r)
	else
		return CompoundAssign.new(op,l,r)

var PATHIFY = do |val|
	if val isa TagAttrValue
		val = val.value

	if val isa ArgList
		val = val.values[0]
		
	while val isa Parens
		val = val.value
	
	if val isa VarOrAccess
		val = val.@variable or val.value
	# console.log "TagData value {val}"

	if val isa Access
		let left = val.left
		let right = val.right isa Index ? val.right.value : val.right

		if left isa VarOrAccess
			left = left.@variable or left.value

		if right isa VarOrAccess
			right = right.@variable or right.value
		
		if val isa IvarAccess
			left ||= val.scope__.context

		if right isa Identifier
			right = helpers.singlequote(String(right.js))
			right = Str.new(right)
		
		return [left,right]

	return val

var OPTS = {}
var ROOT = null

export var NODES = []

var C = do |node,opts|
	typeof node == 'string' ? node : node.c(opts)

var M = do |val,mark,o|
	if mark == undefined
		mark = val

	if mark and mark:startLoc
		val = C(val,o)
		let ref = STACK.incr('sourcePair')
		let start = mark.startLoc
		let end = mark.endLoc
		let m0 = ''
		let m1 = ''

		if start == 0 or start > 0
			m0 = end >= start ? "/*%{start}|{ref}$*/" : "/*%{start}$*/"
			
		if end == 0 or end > 0
			m1 = start >= 0 ? "/*%{end}|{ref}$*/" : "/*%{end}$*/"
		return m0 + val + m1
	return C(val,o)

var MSTART = do |*params|
	for item in params
		if item isa Number
			return item
		if item and item:startLoc isa Function
			return item.startLoc
	return null

var MEND = do |*params|
	for item in params
		if item isa Number
			return item
		if item and item:endLoc isa Function
			return item.endLoc
	return null

var TYP = do |item,format|
	let typ = item.@options and item.@options:datatype
	if typ
		if format == 'jsdoc'
			"/** @type \{{M(typ,typ)}\} */"
		else
			":{M(typ,typ)}"
	else
		""

var LIT = do |val|
	RawScript.new(val)

var SYM = do |val|
	Symbol.new(val)

var KEY = do |val|
	val = val.value if val isa Token
	if val isa String
		if val.match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/)
			val = Identifier.new(val)
		else
			val = Str.new(helpers.singlequote(String(val)))
	return val



var STR = do |val|
	return val if val isa Str
	return Str.new(helpers.singlequote(String(val)))

var IF = do |cond,body,alt|
	var node = If.new(cond,body)
	node.addElse(alt) if alt
	node

var NODIFY = do |val|
	if val == null
		return Nil.new
	elif val == false
		return False.new
	elif val == true
		return True.new
	elif val isa String
		return STR(val)
	elif val isa Number
		return Num.new(val)
	else
		return val

var FN = do |pars,body|
	Func.new(pars,body)

var METH = do |pars,body|
	ClosedFunc.new(pars,body)

var CALL = do |callee,pars = []|
	# possibly return instead(!)
	Call.new(callee,pars)

var GET = do |left,right| OP('.',left,right)

var CALLSELF = do |name,pars = []|
	var ref = Identifier.new(name)
	Call.new(OP('.',SELF,ref),pars)

var BLOCK = do
	Block.wrap([]:slice.call(arguments))

var WHILE = do |test,code|
	While.new(test).addBody(code)



export var SPLAT = do |value|
	Splat.new(value)
	# if value isa Assign
	#	value.left = Splat.new(value.left)
	#	return value
	# else
	#	Splat.new(value)

var SEMICOLON_TEST = /;(\s*\/\/.*)?[\n\s\t]*$/
var RESERVED_TEST = /^(default|char|for)$/

# captures error from parser
export def parseError str, o
	# find nearest token
	var err

	if o:lexer
		var token = o:lexer:yytext
		# console.log o:lexer:pos,token.@loc
		err = ImbaParseError.new({message: str},{
			pos: o:lexer:pos
			tokens: o:lexer:tokens
			token: o:lexer:yytext
			meta: o
		})

		throw err

		# should find the closest token with actual position
		# str = "[{token.@loc}:{token.@len || String(token):length}] {str}"
	var e = Error.new(str)
	e:lexer = o:lexer
	e:options = o
	throw e

def AST.c obj
	typeof obj == 'string' ? obj : obj.c

def AST.compileRaw item
	let o = ''
	if item isa Array
		o = '['
		for v in item
			o += AST.compileRaw(v) + ','
		o = o.slice(0,-1) + ']'

	elif item isa Object
		o = '{'
		for own k,v of item
			# maybe quote?
			o =+ "{k}:{AST.compileRaw(v)},"
		o = o.slice(0,-1) + '}'
	else
		o = JSON.stringify(item)
	return o

def AST.blk obj
	obj isa Array ? Block.wrap(obj) : obj

def AST.sym obj
	# console.log "sym {obj}"
	helpers.symbolize(String(obj))

def AST.cary ary
	ary.map(|v| typeof v == 'string' ? v : v.c )

def AST.dump obj, key
	if obj isa Array
		obj.map do |v| v && v:dump ? v.dump(key) : v
	elif obj and obj:dump
		obj.dump

def AST.compact ary
	if ary isa ListNode
		return ary.compact


	ary.filter do |v| v != undefined && v != null

def AST.reduce res,ary
	for v in ary
		v isa Array ? AST.reduce(res,v) : res.push(v)
	return

def AST.flatten ary, compact = no
	var out = []
	for v in ary
		v isa Array ? AST.reduce(out,v) : out.push(v)
	return out

def AST.loc item
	if !item
		[0,0]
	elif item isa Token
		item.region
	elif item isa Node
		item.loc
	
def AST.parse str, opts = {}
	var indent = str.match(/\t+/)[0]
	# really? Require the compiler, not this
	Imbac.parse(str,opts)

def AST.inline str, opts = {}
	parse(str,opts).body

def AST.node typ, pars
	if typ == 'call'
		if pars[0].c == 'return'
			pars[0] = 'tata'
		Call.new(pars[0],pars[1],pars[2])

def AST.escapeComments str
	return '' unless str
	return str


var shortRefCache = []

def AST.counterToShortRef nr
	var base = "A".charCodeAt(0)

	while shortRefCache:length <= nr
		var num = shortRefCache:length + 1
		var str = ""

		while true
			num -= 1
			str = String.fromCharCode(base + (num % 26)) + str
			num = Math.floor(num / 26)
			break unless num > 0

		shortRefCache.push(str.toLowerCase())

	return shortRefCache[nr]

def AST.truthy node

	if node isa True
		return true

	if node isa False
		return false

	if node:isTruthy
		return node.isTruthy

	return undefined

export class Indentation

	prop open
	prop close

	def initialize a,b
		@open = a
		@close = b
		self

	def isGenerated
		@open and @open:generated

	def aloc
		@open and @open.@loc or 0

	def bloc
		@close and @close.@loc or 0

	def startLoc
		aloc

	def endLoc
		bloc


	def wrap str
		var om = @open and @open.@meta
		var pre = om and om:pre or ''
		var post = om and om:post or ''
		var esc = AST:escapeComments
		var out = @close

		# the first newline should not be indented?

		str = post.replace(/^\n/,'') + str

		str = str.replace(/^/g,"\t").replace(/\n/g,"\n\t").replace(/\n\t$/g,"\n")

		str = pre + '\n' + str
		str += out.c if out isa Terminator
		str = str + '\n' unless str[str:length - 1] == '\n'

		return str

var INDENT = Indentation.new({},{})

class Stash

	def initialize
		@entities = []

	def add item
		@entities.unshift(item)
		self

	def pluck item
		var match = null
		for entity,i in @entities
			if entity == item or entity isa item
				match = entity
				@entities.splice(i,1)
				return match
		return null


export class Stack

	prop loglevel
	prop nodes
	prop scopes
	prop root
	prop state

	def initialize
		reset

	def reset
		@nodes    = []
		@scoping  = []
		@scopes   = []
		@stash    = Stash.new(self)
		@loglevel = 3
		@counter  = 0
		@counters = {}
		@options = {}
		@state = {}
		@es6 = null
		@es5 = null
		@optlevel = null
		@tag = null
		@sfcid = null
		self

	def incr name
		@counters[name] ||= 0
		@counters[name] += 1

	def decr name
		@counters[name] ||= 0
		@counters[name] -= 1

	def generateId ns = 'oid'
		AST.counterToShortRef(STACK.incr('oid'))

	def sfcid
		@sfcid ||= @options:sourcePath and helpers.identifierForPath(@options:sourcePath)

	def stash
		@stash

	def set obj
		@options ||= {}
		for own k,v of obj
			@options[k] = v
		self

	# get and set
	def option key, val
		if val != undefined
			@options ||= {}
			@options[key] = val
			return self

		@options && @options[key]

	def platform
		@options:target

	def filename
		@options:filename

	def sourcePath
		@options:sourcePath
	
	
	def es6
		@es6 ?= !!(@options:es6 or @options:es2015 or env('IMBA_ES6'))

	def es5
		# TODO remove
		@es5 ?= !!(@options:es5 or env('IMBA_ES5'))

	def tsc
		platform == 'tsc'
		
	def format
		@options:format or 'esm'
		
	def cjs
		self.format() == 'cjs' or (!@options:format and platform == 'node')
	
	def esm
		self.format() == 'esm'

	def autocall
		!option(:explicitParens)
		# !@options:explicitParens
		
	def optlevel
		@optlevel ?= (@options:conservative or env('IMBA_CONSERVATIVE') ? 0 : (@options:optlevel or 9)) # stack.option(:conservative)

	def env key
		var val = @options["ENV_{key}"]
		return val if val != undefined

		if F[key] != undefined
			return F[key]
		
		var lowercased = key.toLowerCase
		
		if @options[lowercased] != undefined
			return @options[lowercased]

		# temporary shorthand
		if lowercased == 'es6'
			return self.es6

		if lowercased == 'es5'
			return self.es5

		if platform and key in ['WEB','NODE','WEBWORKER']
			return platform.toUpperCase == key

		# console.log 'lookup env var',key,@options:env

		if var e = @options:env
			if e.hasOwnProperty(key)
				return e[key]
			elif e.hasOwnProperty(key.toLowerCase)
				return e[key.toLowerCase]

		if $node$ and typeof process != 'undefined' and process:env
			val = process:env[key.toUpperCase]
			if val != undefined
				return val
			return null

		return undefined	


	def addScope scope
		@scopes.push(scope)
		self

	def traverse node
		self

	def push node
		@nodes.push(node)
		# not sure if we have already defined a scope?
		self

	def pop node
		@nodes.pop # (node)
		self

	def parent
		@nodes[@nodes:length - 2]

	def current
		@nodes[@nodes:length - 1]

	def up test
		test ||= do |v| !(v isa VarOrAccess)

		var i = @nodes:length - 2

		if test:prototype isa Node
			while i >= 0
				var node = @nodes[i--]
				return node if node isa test
			return null

		while i >= 0
			var node = @nodes[i]
			return node if test(node)
			i -= 1
		return null

	def relative node, offset = 0
		var idx = @nodes.indexOf(node)
		idx >= 0 ? @nodes[idx + offset] : null

	def scope lvl = 0
		var i = @nodes:length - 1 - lvl
		while i >= 0
			var node = @nodes[i]
			return node.@scope if node.@scope
			i -= 1
		return null

	def scopes
		# include deeper scopes as well?
		var scopes = []
		var i = @nodes:length - 1
		while i >= 0
			var node = @nodes[i]
			scopes.push(node.@scope) if node.@scope
			i -= 1
		return scopes

	def method
		up(MethodDeclaration)

	def block
		up(Block)

	def blockpart
		let i = @nodes:length - 1
		while i
			if @nodes[i - 1] isa Block
				return @nodes[i]
			i--
		return

	def isExpression
		var i = @nodes:length - 1
		while i >= 0
			var node = @nodes[i]
			# why are we not using isExpression here as well?
			if node isa Code or node isa Loop
				return false
			if node.isExpression
				return true
			# probably not the right test - need to be more explicit
			i -= 1
		return false

	def toString
		"Stack({@nodes.join(" -> ")})"

	def isAnalyzing
		@analyzing

	def scoping
		@nodes.filter(|n| n.@scope ).map(|n| n.@scope )

# Lots of globals -- really need to deal with one stack per file / context
export var STACK = Stack.new

# use a bitmask for these

export class Node

	prop o
	prop options
	prop traversed

	def safechain
		no

	def oid
		@oid ||= STACK.generateId('')

	# shorthand for the self context for a node
	def slf
		scope__.context

	def p
		# allow controlling this from CLI
		if STACK.loglevel > 0
			console.log(*arguments)
		self

	def typeName
		self:constructor:name

	def namepath
		typeName

	def initialize
		setup
		self

	def setup
		@expression = no
		@traversed = no
		@parens = no
		@cache = null
		@value = null
		self

	def setStartLoc loc
		@startLoc = loc
		return self

	def setEndLoc loc
		@endLoc = loc
		return self

	def setRegion loc
		if loc isa Node
			loc = loc.region

		if loc isa Array
			@startLoc = loc[0]
			@endLoc = loc[1]
		return self

	def setEnds start,end
		if end and end:endLoc
			@endLoc = end.endLoc
		if start and start:startLoc
			@startLoc = start.startLoc
		self

	def startLoc
		@startLoc

	def endLoc
		@endLoc

	def set obj
		@options ||= {}
		for own k,v of obj
			@options[k] = v
		self

	# get and set
	def option key, val
		if val != undefined
			@options ||= {}
			@options[key] = val
			return self

		@options && @options[key]

	def o
		@options ||= {}

	def keyword
		@keyword or (@options and @options:keyword)
		
	def datatype
		@options ? @options:datatype : null

	def configure obj
		set(obj)

	def region
		[0,0]

	def loc
		[0,0]

	def token
		null

	def compile
		self

	def visit
		self

	def stack
		STACK

	def isString
		no

	def isPrimitive deep
		no

	def isReserved
		no

	# should rather do traversals
	# o = {}, up, key, index
	def traverse o
		if @traversed
			return self
		# NODES.push(self)
		@traversed = yes
		let prev
		if o
			prev = STACK.state
			STACK.state = o
		STACK.push self
		visit(STACK,STACK.state)
		STACK.pop self
		if o
			STACK.state = prev
		return self

	def inspect
		{type: self:constructor.toString}

	def js o
		"NODE"

	def toString
		"{self:constructor:name}"

	# swallow might be better name
	def consume node
		if node isa TagLike
			return node.register(self)

		if node isa PushAssign
			node.register(self)
			return PushAssign.new(node.op,node.left,self)

		if node isa Assign
			# node.right = self
			return OP(node.op,node.left,self)
		elif node isa Op
			return OP(node.op,node.left,self)
		elif node isa Return
			return Return.new(self)
		return self

	def toExpression
		@expression = true
		self

	def forceExpression
		@expression = true
		self

	def isExpressable
		true

	def isExpression
		@expression || false

	def hasSideEffects
		true

	def isUsed
		true

	def shouldParenthesize
		false

	def shouldParenthesizeInTernary
		yes

	def block
		Block.wrap([self])

	def node
		self

	def scope__
		STACK.scope

	def up
		STACK.parent

	def util
		Util

	def receiver
		self

	def indented a,b

		if a isa Indentation
			@indentation = a
			return self

		# this is a _BIG_ hack
		if b isa Array
			add(b[0])
			b = b[1]

		# if indent and indent.match(/\:/)
		@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		self

	def prebreak term = '\n'
		self

	def invert
		return OP('!',self)

	def cache o = {}
		@cache = o
		o:var = (o:scope or scope__).temporary(self,o)
		o:lookups = 0
		self

	def cachevar
		@cache && @cache:var

	def decache
		if @cache
			cachevar.free
			@cache = null
		self

	# the "name-suggestion" for nodes if they need to be cached
	def alias
		null

	def warn text, opts = {}
		opts:message = text
		opts:loc ||= loc
		scope__.root.warn opts
		self

	def c o
		var s = STACK
		var ch = @cache
		return c_cached(ch) if ch and ch:cached

		s.push(self)
		forceExpression if o && o:expression

		if o and o:indent
			@indentation ||= INDENT

		var out = js(s,o)

		var paren = shouldParenthesize

		s.pop(self)

		if out == undefined
			return out

		if var indent = @indentation
			out = indent.wrap(out,o)
			self

		# should move this somewhere else really
		out = "({out})" if paren
		if (o and o:braces) or (@options and @options:braces)
			if indent
				out = '{' + out + '}'
			else
				out = '{ ' + out + ' }'

		if ch = @cache
			out = "{ch:var.c} = {out}" unless ch:manual
			var par = s.current
			out = '(' + out + ')' if par isa Access || par isa Op # others? #
			ch:cached = yes

		if OPTS:sourceMap and (!o or o:mark !== false)
			out = M(out,self)
		return out

	def c_cached cache
		cache:lookups++
		cache:var.free if cache:uses == cache:lookups
		return cache:var.c # recompile every time??

export class ValueNode < Node

	prop value

	def startLoc
		@value?.startLoc

	def endLoc
		@value?.endLoc

	def initialize value
		setup
		@value = load(value)

	def load value
		value

	def js o
		typeof @value == 'string' ? @value : @value.c

	def visit

		@value.traverse if @value isa Node #  && @value:traverse
		self

	def region
		[@value.@loc,@value.@loc + @value.@len]

export class ExpressionNode < ValueNode

export class AssertionNode < ValueNode
	def js o
		let op = @value
		let out = []

		if op isa Op and !(op isa Access)
			let l = op.left
			let r = op.right

			out.push(l.cache.c(o))
			out.push(helpers.singlequote(op.@op))
			out.push(r.cache.c(o))
			out = ["imba.$a=[{out.join(',')}]"]
			out.push(op.c(o))
			# op.cache
			# out.push('imba.$asrt=undefined')
			# out.push(op.c(o))
		else
			out.push('imba.$a=null')
			out.push(op.c(o))
		return '(' + out.join(',') + ")" # ,{op.c(o)})
		# "('assert',{super})"

export class Statement < ValueNode

	def isExpressable
		return no


export class Meta < ValueNode

	def isPrimitive deep
		yes

export class Comment < Meta

	def visit
		if @value.type == 'HERECOMMENT'
			let raw = @value.@value
			let line = raw.slice(0,raw.indexOf('\n')).trim

			if let m = line.match(/^(css|less|stylus|sass|scss)( scoped)?/)
				var style = {
					content: raw.slice(raw.indexOf('\n'))
					scoped: !!m[2]
					type: m[1]
					attrs: {}
				}
				# compile style directly here?
				scope__.root.styles.push(style)
				stack.set(hasScopedStyles: yes) if m[2]

		if var block = up
			var idx = block.indexOf(self) + 1
			idx += 1 if block.index(idx) isa Terminator
			if var next = block.index(idx)
				next.@desc = self

		self

	def toDoc
		helpers.normalizeIndentation("" + @value.@value)

	def toJSON
		helpers.normalizeIndentation("" + @value.@value)

	def c o
		return "" if STACK.option(:comments) == false

		var v = @value.@value
		if o and o:expression or v.match(/\n/) or @value.type == 'HERECOMMENT' # multiline?
			var out = v.replace(/\*\//g, '\\*\\/').replace(/\/\*/g, '\\/\\*')
			"/*{out}*/"
		elif v.match(/\@(type|param)/)
			"/** {v} */"
		else
			"// {v}"

export class Terminator < Meta

	def initialize v
		@value = v
		self

	def traverse
		self

	def loc
		[@value.@loc,@value.@loc + @value.@value:length]

	def startLoc
		@value:startLoc ? @value.startLoc : -1

	def endLoc
		@value.@value ? (startLoc + @value.@value:length) : -1

	def c
		let val = @value.c
		if STACK.option(:comments) == false
			val = val.replace(/\/\/.*$/gm,'')

		if STACK.tsc and val:length > 1
			return M(val.replace(/^[\t ]+/gm,''),self)

		return val.replace(/^[\t ]+/gm,'')

export class Newline < Terminator

	def initialize v
		@traversed = no
		@value = v or '\n'

	def c
		@value
		# M(@value,@value)


# weird place?
export class Index < ValueNode

	def cache o = {}
		@value.cache(o)

	def js o
		@value.c

export class ListNode < Node

	prop nodes

	def initialize list
		setup
		@nodes = load(list or [])
		@indentation = null

	# PERF acces @nodes directly?
	def list
		@nodes

	def compact
		@nodes = AST.compact(@nodes)
		self

	def load list
		list

	def concat other
		# need to store indented content as well?
		@nodes = nodes.concat(other isa Array ? other : other.nodes)
		self

	def swap item, other
		var idx = indexOf(item)
		nodes[idx] = other if idx >= 0
		self

	def push item
		@nodes.push(item)
		self

	def pop
		var end = @nodes.pop
		return end

	def add item, o
		let idx = null
		if o and o:before
			idx = @nodes.indexOf(o:before)
			idx = null if idx == -1
		elif o and o:after
			idx = @nodes.indexOf(o:after) + 1
			idx = null if idx == 0
			if idx >= 1
				while @nodes[idx] isa Meta
					idx++
		elif o isa Number
			idx = o

		if idx !== null
			item isa Array ? @nodes.splice(idx,0,*item) : @nodes.splice(idx,0,item)
		else
			item isa Array ? @nodes.push(*item) : @nodes.push(item)
		self

	def unshift item, br
		@nodes.unshift(BR) if br
		@nodes.unshift(item)
		self

	# test
	def slice a, b
		self:constructor.new(@nodes.slice(a,b))

	def break br, pre = no
		br = Terminator.new(br) if typeof br == 'string'
		pre ? unshift(br) : push(br)
		self

	def some cb
		for node in @nodes
			return yes if cb(node)
		return no

	def every cb
		for node in @nodes
			return no unless cb(node)
		return yes
	
	# filtered list of items
	def values
		@nodes.filter do |item| !(item isa Meta)

	def filter cb
		@nodes.filter(cb)

	def pluck cb
		var item = filter(cb)[0]
		remove(item) if item
		return item

	def indexOf item
		@nodes.indexOf(item)

	def index i
		@nodes[i]

	def remove item
		var idx = @nodes.indexOf(item)
		@nodes.splice(idx, 1) if idx >= 0
		self

	def removeAt idx
		var item = @nodes[idx]
		@nodes.splice(idx, 1) if idx >= 0
		return item


	def replace original, replacement
		var idx = @nodes.indexOf(original)
		if idx >= 0
			if replacement isa Array
				@nodes.splice(idx,1,*replacement)
			else
				@nodes[idx] = replacement
		self

	def first
		@nodes[0]

	def last
		var i = @nodes:length
		while i
			i = i - 1
			var v = @nodes[i]
			return v unless v isa Meta
		return null

	def map fn
		@nodes.map(fn)

	def forEach fn
		@nodes.forEach(fn)

	def remap fn
		@nodes = map(fn)
		self

	def count
		@nodes:length

	def len
		@nodes:length

	def realCount
		var k = 0
		for node in @nodes
			k++ if node and !(node isa Meta)
		return k

	def isEmpty
		realCount == 0

	def visit
		let items = @nodes
		let i = 0

		while i < items:length
			let item = items[i]
			let res = item.traverse
			if res != item
				if res isa Array
					items.splice(i,1,*res)
					continue
			i++
		self

	def isExpressable
		for node in nodes
			return no if node and !node.isExpressable

		return yes

	def toArray
		@nodes

	def delimiter
		@delimiter or ","

	def js o, nodes: @nodes
		var delim = ','
		var express = delim != ';'
		var last = last

		var i = 0
		var l = nodes:length
		var str = ""

		for arg in nodes
			var part = typeof arg == 'string' ? arg : (arg ? arg.c(expression: express) : '')

			str += part
			str += delim if part and (!express or arg != last) and !(arg isa Meta)

		return str

	def indented a,b
		if a isa Indentation
			@indentation = a
			return self

		@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		self

	def endLoc
		if @endLoc
			return @endLoc

		var i = @nodes:length
		let last = @nodes[i - 1]
		last?.endLoc


export class ArgList < ListNode

	def consume node
		if node isa TagLike
			@nodes = @nodes.map do |child|
				if !(child isa Meta) # and !(child isa Assign)
					child.consume(node)
				else
					child
			return self
		super

export class AssignList < ArgList

	def concat other
		if @nodes:length == 0 and other isa AssignList
			return other
		else
			super(other)
		# need to store indented content as well?
		# @nodes = nodes.concat(other isa Array ? other : other.nodes)
		self


export class Block < ListNode

	prop head

	def initialize list
		setup
		@nodes = list or []
		@head = null
		@indentation = null
		
	def startLoc
		@indentation ? @indentation.startLoc : super
	
	def endLoc
		@indentation ? @indentation.endLoc : super

	def self.wrap ary
		unless ary isa Array
			throw SyntaxError.new("what")
		ary:length == 1 && ary[0] isa Block ? ary[0] : Block.new(ary)

	def visit stack
		@scope.visit if @scope

		if stack and stack.@tag
			@tag = stack.@tag

		for node,i in @nodes
			# allow replacing blocks?
			node and node.traverse
		
		self

	def block
		self
		
	def collectDecorators
		if let decorators = @decorators
			@decorators = null
			return decorators

	def loc
		# rather indents, no?
		if var opt = option(:ends)
			var a = opt[0].loc
			var b = opt[1].loc

			p "no loc for {opt[0]}" unless a
			p "no loc for {opt[1]}" unless b

			return [a[0],b[1]]

		if var ind = @indentation
			if ind.aloc != -1
				return [ind.aloc,ind.bloc]

		let a = @nodes[0]
		let b = @nodes[@nodes:length - 1]

		[a and a.loc[0] or 0,b and b.loc[1] or 0]

	# go through children and unwrap inner nodes
	def unwrap
		var ary = []
		for node,i in nodes
			if node isa Block
				ary:push.apply(ary,node.unwrap)
			else
				ary.push(node)
		return ary

	# This is just to work as an inplace replacement of nodes.coffee
	# After things are working okay we'll do bigger refactorings
	def compile o = {}
		var root = Root.new(self,o)
		root.compile(o)


	# Not sure if we should create a separate block?
	def analyze o = {}
		self

	def cpart node
		var out = typeof node == 'string' ? node : (node ? node.c : "")
		return "" if out == null or out == undefined or out == ""

		if out isa Array
			var str = ""
			var l = out:length
			var i = 0
			while i < l
				str += cpart(out[i++])
			return str

		var hasSemiColon = SEMICOLON_TEST.test(out)
		out += delimiter unless hasSemiColon or node isa Meta
		return out

	def delimiter
		@delimiter == undefined ? ';' : @delimiter

	def js o, opts
		var ast = @nodes
		var l = ast:length
		# really?
		var express = isExpression or o.isExpression or (option(:express) and isExpressable)
		return '' if ast:length == 0

		if express
			return super(o,nodes: ast)

		var str = ""

		for v in ast
			str += cpart(v)

		# now add the head items as well
		if @head and @head:length > 0
			var prefix = ""
			for v in @head
				var hv = cpart(v)
				prefix += hv + '\n' if hv
			str = prefix + str
			
		if option(:strict)
			str = cpart('"use strict";\n') + str

		return str


	# Should this create the function as well?
	def defers original, replacement
		var idx = @nodes.indexOf(original)
		@nodes[idx] = replacement if idx >= 0
		var rest = @nodes.splice(idx + 1)
		return rest

	def expressions
		var expressions = []
		for node in nodes
			expressions.push(node) unless node isa Terminator
		return expressions


	def consume node
		if node isa TagLike
			let real = expressions

			@nodes = @nodes.map do |child|
				if child in real and !(child isa Assign)
					child.consume(node)
				else
					child
			return self

		# can also return super if it is expressable, but should we really?
		if var before = last
			var after = before.consume(node)
			if after != before
				if after isa Block
					after = after.nodes

				replace(before,after)

		return self


	def isExpressable
		return no unless @nodes.every(|v| v.isExpressable )
		return yes

	def isExpression

		option(:express) || @expression

	def shouldParenthesizeInTernary
		if count == 1
			return first.shouldParenthesizeInTernary

		yes
		
	def indented a,b
		super
		if a isa Token and a.@type == 'INDENT'
			if let post = (a.@meta and a.@meta:post)
				let br = Token.new('TERMINATOR',post)
				@nodes.unshift(Terminator.new(br))
				a.@meta:post = ''
		return self

class ClassInitBlock < Block

class InstanceInitBlock < Block

export class ClassField < Node
	prop name
	prop value

	def initialize name, value
		super
		@name = name
		@value = value

	def visit
		@decorators = up?.collectDecorators
		@name.traverse if @name and @name:traverse

		if @value and STACK.tsc
			@value.@scope = MethodScope.new(@value)
			@value.traverse # if @value # dont traverse yet

		if !STACK.tsc
			@storage = scope__.root.declare(null,LIT('new WeakMap()'))

		# traverse value with a different scope
		self

	def target
		option(:static) ? LIT('this') : LIT('this.prototype')

	def storageKey
		@storageKey ||= STR(name.c + '$$')

	def isPlain
		!@decorators and (!@value or @value.isPrimitive)

	def isLazy
		yes

	def isStatic
		option(:static)

	def loc
		[@name.@loc,@name.region[1]]

	# def js s
	# 	return if s.up isa ClassBody
	# 
	# 	util.setField(slf,@name,@value or LIT('void 0')).c

	def c
		let up = STACK.current
		let out
		if up isa ClassBody
			
			# return if isPlain
			let prefix = isStatic ? "{M('static',option(:static))} " : ''
			let name = name isa IdentifierExpression ? name.asObjectKey : name.c

			if STACK.tsc
				out = "{M(name,@name)}" # the value scope?
				out += " = {@value.c}" if value
				if let typ = TYP(@name,'jsdoc')
					out = "{typ}\n{out}"
			else
				out = "{prefix}set {name}{setter.c(keyword: '')}\n{prefix}get {name}{getter.c(keyword: '')}"

		elif up isa ClassInitBlock and !STACK.tsc
			if !isLazy and isPlain and value
				out = util.setField(target,name,@value).c + ';\n'
			# else
			# 	let obj = Obj.wrap(enumerable: false, writable: true, value: LIT('undefined'))
			# 	out = util.initField(target,storageKey,obj).c + ';\n'

		elif up isa InstanceInitBlock and !isStatic and !isLazy and !STACK.tsc
			if value
				# out = util.setField(THIS,name,value).c + ';\n'
				out = OP('.',THIS,name).c + ';\n'

		return out


	def getter
		@getter ||= if true
			# let op = OP('.',THIS,storageKey)
			let op = CALL(GET(@storage,'get'),[THIS])
			let getter = op
			if value # and (!(value isa Str) and !(value isa Str) and !(value isa Bool) or @decorators)
				let inlined = (value isa Num) or (value isa Str) or (value isa Bool)
				let has = CALL(GET(@storage,'has'),[THIS])
				if inlined
					op = METH([],[If.ternary(has,op,value)])
				else
					let setter = CALL(GET(@storage,'set'),[THIS,value])
					op = IF(OP('!',has),setter)
					op = METH([],[op,BR,getter])
				op.traverse
				return op
			else
				return FN([],[op])

	def setterForValue value
		OP('=',OP('.',THIS,storageKey),value)

	def setter
		@setter ||= if true
			let op = CALL(GET(@storage,'set'),[THIS,LIT('value')])
			# OP('=',OP('.',THIS,storageKey),LIT('value'))
			FN([LIT('value')],[op])

	def decorater
		@decorater ||= if true
			# let target = option(:static) ? LIT('this') : LIT('this.prototype')
			util.decorate(Arr.new(@decorators),target,name,LIT('null'))


export class ClassBody < Block

	def setup
		super
		@fields = []
		@staticFields = []

	def visit stack
		@scope.visit if @scope

		if stack and stack.@tag
			@tag = stack.@tag

		for node,i in @nodes
			node and node.traverse
		self

export class ExpressionList < Block

export class VarDeclList < Block
	
	def type
		option(:type) or 'var'

	def add part
		push(BR) if @nodes:length

		if true
			let node = VarDeclaration.new(part[0],part[1],type).set(decl: self, datatype: part[0].option(:datatype))
			push(node)
			return self

		let expr = VarReference.new(part[0],type).set(decl: self, datatype: part[0].option(:datatype))
		# should we not have special VarAssign blocks?
		push(part[1] ? Assign.new('=',expr,part[1]) : expr)

	def consume node
		return self


# Could inherit from valueNode
export class Parens < ValueNode

	def initialize value, open, close
		setup
		@open = open
		@close = close
		@value = load(value)

	def load value
		@noparen = no
		value isa Block and value.count == 1 ? value.first : value

	def isString
		# checking if this is an interpolated string
		@open and String(@open) == '("' or value.isString

	def js o

		var par = up
		var v = @value
		var str = null

		@noparen = yes if v isa Func

		if par isa Block
			# is it worth it?
			@noparen = yes unless o.isExpression
			str = v isa Array ? AST.cary(v) : v.c(expression: o.isExpression)
		else
			str = v isa Array ? AST.cary(v) : v.c(expression: yes)

		# check if we really need parens here?
		return str

	def set obj
		console.log "Parens set {JSON.stringify(obj)}"
		super(obj)


	def shouldParenthesize
		# no need to parenthesize if this is a line in a block
		return no if @noparen #  or par isa ArgList
		return yes


	def prebreak br
		super(br)
		console.log "PREBREAK"
		@value.prebreak(br) if @value
		self


	def isExpressable
		@value.isExpressable

	def consume node
		@value.consume(node)


# Could inherit from valueNode
# an explicit expression-block (with parens) is somewhat different
# can be used to return after an expression
export class ExpressionBlock < ListNode


	def c o
		map(|item| item.c(o) ).join(",")

	def consume node
		value.consume(node)


# STATEMENTS

export class Return < Statement

	prop value

	def initialize v
		@traversed = no
		@value = v isa ArgList and v.count == 1 ? v.last : v
		return self

	def visit
		@value.traverse if @value && @value:traverse

	def startLoc
		let l = (keyword or @value)
		l ? l.startLoc : null

	def js o
		var v = @value
		let k = M('return',keyword)

		if v isa ArgList
			return "{k} [{v.c(expression: yes)}]"
		elif v
			return "{k} {v.c(expression: yes)}"
		else
			k

	def c
		return super if !value or value.isExpressable
		value.consume(self).c

	def consume node
		return self

export class ImplicitReturn < Return

export class GreedyReturn < ImplicitReturn

# cannot live inside an expression(!)
export class Throw < Statement

	def js o
		"throw {value.c}"

	def consume node
		# ROADMAP should possibly consume to the value of throw and then throw?
		return self


export class LoopFlowStatement < Statement

	prop literal
	prop expression

	def initialize lit, expr
		self.literal = lit
		self.expression = expr

	def visit
		expression.traverse if expression

	def consume node
		self

	def c
		return super unless expression
		# get up to the outer loop
		var _loop = STACK.up(Loop)

		# need to fix the grammar for this. Right now it
		# is like a fake call, but should only care about the first argument
		var expr = self.expression

		if _loop.catcher
			expr = expr.consume(_loop.catcher)
			var copy = self:constructor.new(literal)
			Block.new([expr,copy]).c
		elif expr
			var copy = self:constructor.new(literal)
			Block.new([expr,copy]).c
		else
			super
		# return "loopflow"


export class BreakStatement < LoopFlowStatement
	def js o do "break"

export class ContinueStatement < LoopFlowStatement
	def js o do "continue"

export class DebuggerStatement < Statement


# PARAMS

export class Param < Node

	prop name
	prop index
	prop defaults
	prop splat
	prop variable
	prop value

	def initialize value, defaults, typ
		# could have introduced bugs by moving back to identifier here
		if typeof value == 'string'
			value = Identifier.new(value)

		@traversed = no
		@name = value
		@value = value
		@defaults = defaults
		@typ = typ
		@variable = null

	def varname
		@variable ? @variable.c : name
		
	def jsdoc
		let typ = option('datatype')
		if typ && name
			'@param {' + typ.c() + '} ' + name
		else
			''

	def js o
		if @defaults
			return "{@value.c} = {@defaults.c}"
		elif option(:splat)
			return "..." + @value.c
		else
			return @value.c

		return @variable.c if @variable

	def visit
		@value.traverse if @value
		@defaults.traverse if @defaults
		self.variable ||= scope__.register(name,self)

		if @name isa Identifier
			# change type here?
			@name.@value.@type = "PARAMVAR" if @name.@value
			@name.references(@variable)
			@variable.addReference(@name)

		self

	def assignment
		OP('=',variable.accessor,defaults)

	def isExpressable
		!defaults || defaults.isExpressable

	def dump
		{loc: loc}

	def loc
		@name && @name.region

	def toJSON
		{
			type: typeName
			name: name
			defaults: defaults
		}

export class BlockParam < Param

	def c
		"blockparam"

	def loc
		# hacky.. cannot know for sure that this is right?
		var r = name.region
		[r[0] - 1,r[1]]


export class OptionalParam < Param

export class NamedParam < Param

export class RequiredParam < Param

export class NamedParams < ListNode

	prop index
	prop variable

	def load list
		var load = (|k| NamedParam.new(k.key,k.value) )
		list isa Obj ? list.value.map(load) : list

	def visit
		var s = scope__
		@variable ||= s.temporary(self, pool: 'keypars')
		@variable.predeclared

		# this is a listnode, which will automatically traverse
		# and visit all children
		super
		# register the inner variables as well(!)
		self


	def varname
		variable.c

	def name
		varname

	def js o
		"namedpar"

	def toJSON
		{
			type: typeName
			nodes: filter(|v| v isa NamedParam)
		}


export class IndexedParam < Param

	prop parent
	prop subindex

	def visit
		# BUG The defaults should probably be looked up like vars
		self.variable ||= scope__.register(name,self)
		self.variable.proxy(parent.variable,subindex)
		self


export class ArrayParams < ListNode

	prop index
	prop variable

	def visit
		var s = scope__
		@variable ||= s.temporary(self, pool: 'keypars')
		@variable.predeclared

		# now when we loop through these inner params - we create the pars
		# with the correct name, but bind them to the parent
		super

	def name
		variable.c

	def load list
		return null unless list isa Arr
		# try the basic first
		unless list.splat
			list.value.map do |v,i|
				# must make sure the params are supported here
				# should really not parse any array at all(!)
				var name = v
				if v isa VarOrAccess
					# FIX?
					name = v.value.value
					# this is accepted
				parse(name,v,i)

	def parse name,child,i
		var param = IndexedParam.new(name,null)

		param.parent = self
		param.subindex = i
		param

	def head ast
		self

export class ParamList < ListNode

	prop splat
	prop block

	def at index, force = no, name = null
		if force
			add(Param.new(count == index && name || "_{count}")) until count > index
			# need to visit at the same time, no?
		list[index]

	def metadata
		filter(|par| !(par isa Meta))

	def toJSON
		metadata
		
	def jsdoc
		let out = []
		for item in nodes when item isa Param
			if item.option(:datatype)
				out.push(item.jsdoc())
		let doc = out.join('\n')
		return (doc ? '/**\n' + doc + '\n*/\n' : '')

	def visit
		var blk = filter(|par| par isa BlockParam)

		if blk:length > 1
			blk[1].warn "a method can only have one &block parameter"

		elif blk[0] && blk[0] != last
			blk[0].warn "&block must be the last parameter of a method"
			# warn "&block must be the last parameter of a method", blk[0]

		# add more warnings later(!)
		# should probably throw error as well to stop compilation

		# need to register the required-pars as variables
		super

	def js o
		return EMPTY if count == 0

		if o.parent isa Block
			return head(o)

		# items = map(|arg| arg.name.c ).compact
		# return null unless items[0]

		if o.parent isa Code
			# return "params_here"
			# remove the splat, for sure.. need to handle the other items as well
			# this is messy with references to argvars etc etc. Fix
			var pars = nodes
			# pars = filter(|arg| arg != @splat && !(arg isa BlockParam)) if @splat
			# pars = filter(|arg| arg isa RequiredParam or arg isa OptionalParam) if @splat
			AST.compact(nodes.map(|param| param.c() )).join(",")
		else
			throw "not implemented paramlist js"
			"ta" + AST.compact(map(|arg| arg.c )).join(",")

	def head o
		var reg = []
		var opt = []
		var blk = null
		var splat = null
		var named = null
		var arys = []
		var signature = []
		var idx = 0

		nodes.forEach do |par,i|
			if par isa RawScript
				return

			par.index = idx
			if par isa NamedParams
				signature.push('named')
				named = par
			elif par isa OptionalParam
				signature.push('opt')
				opt.push(par)
			elif par isa BlockParam
				signature.push('blk')
				blk = par
			# elif par isa SplatParam
			# 	signature.push('splat')
			# 	splat = par
			# 	idx -= 1 # this should really be removed from the list, no?
			elif par isa ArrayParams
				arys.push(par)
				signature.push('ary')
			else
				signature.push('reg')
				reg.push(par)
			idx++

		if named
			var namedvar = named.variable

		# var opt = nodes.filter(|n| n isa OptionalParam)
		# var blk = nodes.filter(|n| n isa BlockParam)[0]
		# var splat = nodes.filter(|n| n isa SplatParam)[0]

		# simple situation where we simply switch
		# can probably optimize by not looking at arguments at all
		var ast = []
		var isFunc = do |js| "typeof {js} == 'function'"

		# This is broken when dealing with iframes anc XSS scripting
		# but for now it is the best test for actual arguments
		# can also do constructor.name == 'Object'
		var isObj = do |js| "{js}.constructor === Object"
		var isntObj = do |js| "{js}.constructor !== Object"
		# should handle some common cases in a cleaner (less verbose) manner
		# does this work with default params after optional ones? Is that even worth anything?
		# this only works in one direction now, unlike TupleAssign

		# we dont really check the length etc now -- so it is buggy for lots of arguments

		# if we have optional params in the regular order etc we can go the easy route
		# slightly hacky now. Should refactor all of these to use the signature?
		if !named && !splat && !blk && opt:length > 0 && signature.join(" ").match(/opt$/)
			for par,i in opt
				ast.push "if({par.name.c} === undefined) {par.name.c} = {par.defaults.c}"


		elif named && !splat && !blk && opt:length == 0 # and no block?!
			# different shorthands
			# if named
			ast.push "if(!{namedvar.c}||{isntObj(namedvar.c)}) {namedvar.c} = \{\}"

		elif blk && opt:length == 1 && !splat && !named
			var op = opt[0]
			var opn = op.name.c
			var bn = blk.name.c
			ast.push "if({bn}==undefined && {isFunc(opn)}) {bn} = {opn},{opn} = {op.defaults.c}"
			ast.push "if({opn}==undefined) {opn} = {op.defaults.c}"

		elif blk && named && opt:length == 0 && !splat
			var bn = blk.name.c
			ast.push "if({bn}==undefined && {isFunc(namedvar.c)}) {bn} = {namedvar.c},{namedvar.c} = \{\}"
			ast.push "else if(!{namedvar.c}||{isntObj(namedvar.c)}) {namedvar.c} = \{\}"

		elif opt:length > 0 || splat # && blk  # && !splat

			var argvar = scope__.temporary(self, pool: 'arguments').predeclared.c
			var len = scope__.temporary(self, pool: 'counter').predeclared.c

			var last = "{argvar}[{len}-1]"
			var pop = "{argvar}[--{len}]"
			ast.push "var {argvar} = arguments, {len} = {argvar}.length"

			if blk
				var bn = blk.name.c
				if splat
					ast.push "var {bn} = {isFunc(last)} ? {pop} : null"
				elif reg:length > 0
					# ast.push "// several regs really?"
					ast.push "var {bn} = {len} > {reg:length} && {isFunc(last)} ? {pop} : null"
				else
					ast.push "var {bn} = {isFunc(last)} ? {pop} : null"

			# if we have named params - look for them before splat
			# should probably loop through pars in the same order they were added
			# should it be prioritized above optional objects??
			if named
				# should not include it when there is a splat?
				ast.push "var {namedvar.c} = {last}&&{isObj(last)} ? {pop} : \{\}"

			for par,i in opt
				ast.push "if({len} < {par.index + 1}) {par.name.c} = {par.defaults.c}"

			# add the splat
			if splat
				var sn = splat.name.c
				var si = splat.index

				if si == 0
					ast.push "var {sn} = new Array({len}>{si} ? {len} : 0)"
					ast.push "while({len}>{si}) {sn}[{len}-1] = {pop}"
				else
					ast.push "var {sn} = new Array({len}>{si} ? {len}-{si} : 0)"
					ast.push "while({len}>{si}) {sn}[--{len} - {si}] = {argvar}[{len}]"

			# if named
			# 	for k,i in named.nodes
			# 		# OP('.',namedvar) <- this is the right way, with invalid names etc
			# 		var op = OP('.',namedvar,k.key).c
			# 		ast.push "var {k.key.c} = {op} !== undefined ? {op} : {k.value.c}"

			# if named

			# return ast.join(";\n") + ";"
			# return "if({opt[0].name.c} instanceof Function) {blk.c} = {opt[0].c};"


		elif opt:length > 0
			for par,i in opt
				ast.push "if({par.name.c} === undefined) {par.name.c} = {par.defaults.c}"

		# now set stuff if named params(!)

		if named
			for k,i in named.nodes
				# console.log "named var {k.c}"
				var op = OP('.',namedvar,k.c).c
				ast.push "var {k.c} = {op} !== undefined ? {op} : {k.defaults.c}"

		if arys:length
			for v,i in arys
				# create tuples
				v.head(o,ast,self)
				# ast.push v.c



		# if opt:length == 0
		return ast:length > 0 ? (ast.join(";\n") + ";") : EMPTY


# Legacy. Should move away from this?
export class ScopeVariables < ListNode

	# for later, moz-ast style
	prop kind

	# we want to register these variables in
	def add name, init, pos = -1
		var vardec = VariableDeclarator.new(name,init)
		vardec.variable = name if name isa Variable
		pos == 0 ? unshift(vardec) : push(vardec)
		vardec

	def load list
		# temporary solution!!!
		list.map do |par| VariableDeclarator.new(par.name,par.defaults,par.splat)

	def isExpressable
		nodes.every(|item| item.isExpressable)

	def js o
		return EMPTY if count == 0

		# When is this needed?
		if count == 1 && !isExpressable
			first.variable.autodeclare
			var node = first.assignment
			return node.c

		
		var keyword = 'var'
		var groups = {}

		nodes.forEach do |item|
			let typ = item.@variable and item.@variable.type
			groups[typ] ||= []
			groups[typ].push(item.@variable)

		if groups['let'] and (groups['var'] or groups['const'])
			groups['let'].forEach do |item| item.@virtual = yes
		elif groups['let'] and !o.es5
			keyword = 'let'

		# FIX PERFORMANCE
		var out = AST.compact(AST.cary(nodes)).join(", ")
		out ? "{keyword} {out}" : ""

export class VariableDeclarator < Param
	
	prop type
	# can possibly create the variable immediately but wait with scope-declaring
	# What if this is merely the declaration of a system/temporary variable?
	def visit
		# even if we should traverse the defaults as if this variable does not exist
		# we need to preregister it and then activate it later
		self.variable ||= scope__.register(name,null, type: @type or 'var')
		defaults.traverse if defaults
		# WARN what if it is already declared?
		self.variable.declarator = self
		self.variable.addReference(name)
		self

	# needs to be linked up to the actual scoped variables, no?
	def js o
		return null if variable.@proxy

		var defs = defaults
		# FIXME need to deal with var-defines within other statements etc
		# FIXME need better syntax for this
		if defs != null && defs != undefined
			# console.log "defaults is {defaults}"
			defs = defs.c(expression: yes) if defs isa Node

			"{variable.c} = {defs}"
		else
			"{variable.c}"

	def accessor
		self


export class VarDeclaration < Node

	prop kind
	prop left
	prop right
	
	def type
		@kind

	def initialize left, right, kind
		@left = left
		@right = right
		@kind = kind
		
	def visit
		@right.traverse if @right
		@left.traverse(declaring: type) if @left
		
		# replace directly
		# should the left side be wrapped in a VarDeclLeft node?
		if @left isa Identifier
			# TODO add an identifier.declare method for this
			@left.@variable ||= scope__.register(@left.symbol,@left,type: type)

		# elif @left isa Obj
		# 	# need to traverse the object to register variables
		# 	# if it is a let we might also need to rename them though
			
		self
		
	def consume node
		if node isa TagLike
			return self
		
		super(node)
		
	def c o
		if right and !right.isExpressable
			# TODO write failing tests and make them pass
			return right.consume(self).c(o)
		# testing this
		return super(o)
		
	def js
		let out = "{M(kind,kind)} {left.c()}"
		if right
			out += " = {right.c(expression: true)}"
			
		if option(:export)
			if STACK.cjs
				out = "{out};\nexports.{left.c()} = {left.c()}"
			else
				out = M('export',option(:export)) + " {out}"
			
		if let typ = datatype
			out = '/** @type {' + typ.c() + '} */\n' + out

		return out

# TODO clean up and refactor all the different representations of vars
# VarName, VarReference, LocalVarAccess?
export class VarName < ValueNode

	prop variable
	prop splat

	def initialize a,b
		super
		@splat = b

	def visit
		# should we not lookup instead?
		# FIXME p "register value {value.c}"
		self.variable ||= scope__.register(value.c,null)
		self.variable.declarator = self
		self.variable.addReference(value)
		self

	def js o
		variable.c

	def c
		variable.c

# CODE

export class Code < Node

	prop head
	prop body
	prop scope
	prop params

	def scopetype
		Scope

	def visit
		@scope.visit if @scope
		# @scope.parent = STACK.scope(1) if @scope
		self


# Rename to Program?
export class Root < Code

	def initialize body, opts
		@traversed = no
		@body = AST.blk(body)
		@scope = RootScope.new(self,null)
		@options = {}

	def loc
		@body.loc

	def visit
		ROOT = STACK.ROOT = @scope
		scope.visit
		body.traverse

	def compile o
		STACK.reset # -- nested compilation does not work now
		@scope.options = OPTS = STACK.@options = @options = o or {}
		STACK.root = @scope
		traverse
		STACK.root = @scope

		var out = c

		if STACK.tsc
			out = "import 'imba/index';\n{out}"

		var result = {
			js: out,
			ast: self,
			source: o.@source,
			warnings: scope.warnings,
			options: o,
			toString: (do this:js)
			styles: scope.styles,
			sfcid: @scope.sfcid
		}

		var stylebody = ""
		for style in result:styles
			if style:type == 'css'
				let scoping = style:scoped ? result:sfcid : null
				style:processed = csscompiler.compile(style:content,scope: scoping)
				stylebody += style:processed + '\n'

		if stylebody
			let css = {js: stylebody}
			result:js = "imba.inlineStyles({JSON.stringify(css:js)});\n{result:js}"

		# always create the sourcemap?
		if o:sourceMap # should handle sourcemap no matter what?
			let map = SourceMap.new(result,o:sourceMap,o).generate
			result:sourcemap = map.result
		# else
		# remove sourcemap locations
		result:js = result:js.replace(/\/\*\%([\w\|]*)\$\*\//g,'')

		return result

	def js o
		var out
		unless @options:wrap
			out = scope.c
		else
			body.consume(ImplicitReturn.new)
			out = scope.c(indent: yes)
			out = out.replace(/^\n?/,'\n')
			out = out.replace(/\n?$/,'\n\n')
			out = '(function(){' + out + '})();'

		# find and replace shebangs
		var shebangs = []
		out = out.replace(/^[ \t]*\/\/(\!.+)$/mg) do |m,shebang|
			shebang = shebang.replace(/\bimba\b/g,'node')
			shebangs.push("#{shebang}\n")
			return ""

		out = shebangs.join('') + out

		return out


	def analyze o = {}
		# loglevel: 0, entities: no, scopes: yes
		STACK.loglevel = o:loglevel or 0
		STACK.@analyzing = true
		ROOT = STACK.ROOT = @scope
		OPTS = STACK.@options = {
			target: o:target
			loglevel: o:loglevel or 0
			analysis: {
				entities: (o:entities or no),
				scopes: (o:scopes ?= yes)
			}
		}

		traverse
		STACK.@analyzing = false

		return scope.dump

	def inspect
		true

export class ClassDeclaration < Code

	prop name
	prop superclass
	prop initor

	def consume node
		if node isa Return
			option('return',node)
			return self
		super

	def namepath
		@namepath ||= "{name ? name.c : '--'}"

	def metadata
		{
			type: 'class'
			namepath: namepath
			inherits: superclass?.namepath
			path: name and name.c.toString
			desc: @desc
			loc: loc
			symbols: @scope.entities
		}
		
	def loc
		if let d = option(:keyword)
			[d.@loc,body.loc[1]]
		else
			super

	def startLoc
		@startLoc ?= MSTART(option(:export),option(:keyword))

	def endLoc
		@endLoc ?= MEND(body)

	def toJSON
		metadata

	def initialize name, superclass, body
		# what about the namespace?
		@traversed = no
		@name = name or LIT('')
		@superclass = superclass
		@scope = isTag ? TagScope.new(self) : ClassScope.new(self)
		@body = AST.blk(body) or ClassBody.new([])
		@entities = {} # items should register the entities as they come
		self

	def isTag
		no

	def staticInit
		@staticInit ||= addMethod('init$',[],@superclass ? 'super.inherited instanceof Function && super.inherited(this)' : 'this').set(static: yes)

	def instanceInit
		@instanceInit ||= addMethod('init$',[],isTag ? 'super.init$()' : '')

	def visit
		# replace with some advanced lookup?
		@body.@delimiter = ''
		ROOT.entities.add(namepath,self)
		scope.visit

		if @superclass and !option(:extension) and !STACK.tsc
			# addMethod('super$',[LIT('k')],'super[k]')
			# addMethod('super$set',[LIT('k,v')],'super[k] = v')
			staticInit

		body.traverse

		if STACK.tsc
			return self

		var inits = InstanceInitBlock.new()
		var staticInits = ClassInitBlock.new()
		var ctor = body.option(:ctor)

		for node in body when node isa ClassField
			staticInits.add(node)
			inits.add(node)

		for node,i in body
			if node.@decorators
				let target = node.option(:static) ? THIS : PROTO
				let desc = LIT('null')
				let op = util.decorate(Arr.new(node.@decorators),target,node.name,desc)
				staticInits.add([op,BR])
				# LIT(node.name.c)

		if !inits.isEmpty
			if isTag
				ctor = instanceInit
				ctor.inject(inits)

			elif ctor
				let after = ctor.option(:injectInitAfter)
				# inject before/after super or something
				ctor.inject(inits,after ? {after: after} : 0)
			else
				ctor = addMethod('constructor',[],superclass ? 'super(...arguments)' : 'this')
				ctor.inject(BR)
				ctor.inject(inits)

		if !staticInits.isEmpty
			staticInit.inject(staticInits,0)
		self

	def addMethod name, params, mbody, options
		mbody = [LIT(mbody)] if mbody isa String
		let func = MethodDeclaration.new(params,mbody or [],Identifier.new(name),null,{})
		self.body.unshift(func,yes)
		func.traverse
		return func

	# def addGetter name, body

	# def addSetter name, body

	def js o
		scope.virtualize # is this always needed?
		scope.context.value = name
		scope.context.reference = name

		# should probably also warn about stuff etc
		if option(:extension)
			# fields are not allowed in class extensions?
			@body.@delimiter = ','
			@body.set(braces: yes)
			# TODO should rather declare a variable for the class name, and refer to that?
			return util.extend(LIT(name.c),body).c
			# return body.c

		# if there are superclasses - add to the body
		# addMethod('super$set','return super[k] = v')


		var o = @options or {}
		var cname = name isa Access ? name.right : name
		# var namespaced = name != cname
		var initor = null
		var sup = superclass

		unless typeof cname == 'string'
			cname = cname.c(mark: yes)

		var cpath = typeof name == 'string' ? name : name.c

		@cname = cname
		@cpath = cpath

		let jsbody = '{' + body.c() + '}'
		let jshead = M(keyword,keyword) # "{C(keyword,mark: yes)}"
		jshead += " {M cname, name}" if name
		jshead += " extends {M(sup)}" if sup
		
		if option(:export) and STACK.cjs
			let exportName = option(:default) ? 'default' : cname
			jsbody = "{jsbody};\n{M('exports',o:export)}.{exportName} = {cname}"
				
		elif option(:export) and option(:default)
			jshead = "{M 'export',option(:export)} {M 'default',option(:default)} {jshead}"
		elif option(:export)
			jshead = "{M 'export',option(:export)} {jshead}"


		let js = "{jshead} {jsbody}"
		if option(:global)
			js = "{js}; {scope__.root.globalRef}.{@cname} = {@cname}"

		if @staticInit
			js = "{js}; {cname}.init$();"

		return js

export class TagDeclaration < ClassDeclaration

	def isTag
		yes

	def namepath
		"<{name}>"

	def metadata
		Object.assign(super,{
			type: 'tag'
		})

	def visit
		scope__.imbaDependency('index')

		super

		let sup = superclass

		if sup and (sup.isNative or sup.isNativeSVG) and !STACK.tsc
			# console.log 'inheriting from native element'
			let op = sup.nativeCreateNode
			op = util.extendTag(op,THIS)
			addMethod('create$',[],[op]).set(static: yes)
			set(extends: Obj.wrap(extends: sup.name))
		# if name.name.indexOf('-') == -1 or superclass and superclass.isNativeSVG
		#	console.log("non-native tag?")

	def js s
		scope.virtualize # is this always needed?
		scope.context.value = name
		scope.context.reference = name

		if s.option(:hasScopedStyles)
			# @scope.root.styles:length > 0
			instanceInit.inject LIT("this.setAttribute('data-{@scope.root.sfcid}','')")

		# should probably also warn about stuff etc
		let sup = CALL(LIT('imba.tags.get'),[
			superclass or STR('component'),
			superclass ? STR(superclass.toClassName) : STR('ImbaElement')
		])

		if STACK.tsc
			sup = superclass ? superclass.toClassName : LIT('HTMLElement')

		if option(:extension)
			# TODO remove support - throw when trying to extend
			@body.@delimiter = ','
			@body.set(braces: yes)
			let cls = CALL(LIT('imba.tags.get'),[name,STR(name.toClassName)])
			let tagname = TagTypeIdentifier.new(name)
			return util.extend(cls,body).c

		let className = name.toClassName
		let closure = scope__.parent
		let jsbody = '{' + body.c() + '}'
		let jshead = "{M 'class', keyword} {M className, name} extends {M sup, superclass}"

		let js = "{jshead} {jsbody}"

		if !STACK.tsc
			if @staticInit
				js += "; {className}.init$()"
			let ext = (option(:extends) or LIT('{}')).c
			js += "; imba.tags.define({name.c},{className},{ext})"
		else
			js += "; globalThis.{M className, name} = {className}"
		return js

export class Func < Code

	prop name
	prop params
	prop target
	prop options
	prop type
	prop context

	def scopetype do FunctionScope

	def initialize params, body, name, target, o
		@options = o
		var typ = scopetype
		@traversed = no
		@body = AST.blk(body)
		@scope ||= (o and o:scope) || typ.new(self)
		@scope.params = @params = ParamList.new(params)
		@name = name || ''
		@target = target
		@type = :function
		@variable = null
		self

	def inject line, o
		@body.add([line,BR],o)

	def nonlocals
		@scope.@nonlocals

	def visit
		scope.visit
		@context = scope.parent
		@params.traverse(declaring: 'arg')
		@body.traverse # so soon?

	def funcKeyword
		let str = "function"
		str = "async {str}" if option(:async)
		return str

	def js s,o
		body.consume(ImplicitReturn.new) unless option(:noreturn)
		var ind = body.@indentation
		# var s = ind and ind.@open
		body.@indentation = null if ind and ind.isGenerated
		var code = scope.c(indent: (!ind or !ind.isGenerated), braces: yes)

		# args = params.map do |par| par.name
		# head = params.map do |par| par.c
		# code = [head,body.c(expression: no)].AST.flatten.compact.join("\n").wrap
		# FIXME creating the function-name this way is prone to create naming-collisions
		# will need to wrap the value in a FunctionName which takes care of looking up scope
		# and possibly dealing with it
		var name = typeof @name == 'string' ? @name : @name.c
		name = name ? ' ' + name.replace(/\./g,'_') : ''
		var keyword = o and o:keyword != undefined ? o:keyword : funcKeyword
		var out = "{M(keyword,option('def') or option('keyword'))}{name}({params.c}) " + code
		# out = "async {out}" if option(:async)
		out = "({out})()" if option(:eval)
		return out

	def shouldParenthesize par = up
		par isa Call && par.callee == self
		# if up as a call? Only if we are


export class Lambda < Func
	def scopetype
		var k = option(:keyword)
		(k and k.@value == 'Æ’') ? (MethodScope) : (LambdaScope)

export class ClosedFunc < Func
	def scopetype
		MethodScope

export class TagFragmentFunc < Func

	def scopetype
		# caching still needs to be local no matter what?
		option(:closed) ? (MethodScope) : (LambdaScope)

export class MethodDeclaration < Func

	prop variable
	prop decorators

	def scopetype do MethodScope

	def consume node
		if node isa Return
			option('return',yes)
			return self
		super

	def identifier
		@name

	def metadata
		{
			type: "method"
			name: "" + name
			namepath: namepath
			params: @params.metadata
			desc: @desc
			scopenr: scope.@nr
			loc: loc
		}

	def loc
		if let d = option(:def)
			let end = body.option(:end) or body.loc[1]
			[d.@loc,end]
		else
			[0,0]

	def isGetter
		@type == 'get'

	def isSetter
		@type == 'set'

	def isConstructor
		String(name) == 'constructor'

	def toJSON
		metadata

	def namepath
		return @namepath if @namepath

		var name = String(name.c)
		var sep = (option('static') ? '.' : '#')
		if target
			let ctx = target
			# console.log "target?? {@target.@parent} {@context.node}"
			if ctx.namepath == "ValueNode"
				ctx = @context.node

			@namepath = ctx.namepath + sep + name
		else
			@namepath = '&' + name

	def visit
		@type = option(:type) or (option(:def)?.@value or 'def')
		@decorators = up?.collectDecorators

		var o = @options
		scope.visit

		var closure = @context = scope.parent.closure

		@params.traverse
		
		if option(:inObject)
			@body.traverse
			return self
			
		if target isa Identifier
			if let variable = scope.lookup(target.toString)
				target = variable
			# should be changed to VarOrAccess?!

		if String(name) == 'initialize' and (closure isa ClassScope) and !(closure isa TagScope)
			self.type = :constructor

		if String(name) == 'constructor' or isConstructor
			up.set(ctor: self)
			set(noreturn: yes)
		
		# instance-method / member
		if closure isa ClassScope and !target
			@target = closure.prototype
			set(
				prototype: @target,
				inClassBody: yes,
				inExtension: closure.node.option('extension')
			)
			closure.annotate(self)

		if target isa Self
			@target = closure.context
			closure.annotate(self)
			set(static: yes)
			
		elif o:variable
			@variable = scope.parent.register(name, self, type: String(o:variable))
			warn "{String(o:variable)} def cannot have a target" if target

		elif !target
			yes
		
		if o:export and !(closure isa RootScope)
			warn("cannot export non-root method", loc: o:export.loc)

		ROOT.entities.add(namepath,self)
		@body.traverse

		if isConstructor and option(:supr)
			let ref = scope__.context.@reference
			let supr = option(:supr)
			let node = supr:node
			let block = supr:block

			if ref
				ref.declarator.@defaults = null
				let op = OP('=',ref,This.new)
				block.replace node, [node,op]

		self

	def supername
		type == :constructor ? type : name


	# FIXME export global etc are NOT valid for methods inside any other scope than
	# the outermost scope (root)

	def js o
		var o = @options
		# FIXME Do this in the grammar - remnants of old implementation
		unless type == :constructor or option(:noreturn) or isSetter()
			if option(:chainable)
				body.add(ImplicitReturn.new(scope.context))
			elif option(:greedy)
				# haaack
				body.consume(GreedyReturn.new)
			else
				body.consume(ImplicitReturn.new)

		var code = scope.c(indent: yes, braces: yes)
		var name = typeof @name == 'string' ? @name : @name.c()

		var out = ""
		var fname = AST.sym(self.name)

		if option(:inClassBody) or option(:inObject)
			# what if this is async?
			let prefix = self.isGetter() ? 'get ' : (self.isSetter() ? 'set ' : '')
			prefix = "{M('static',option(:static))} {prefix}" if option(:static)
			prefix = "async {prefix}" if option(:async)
			out = "{prefix}{M name, @name}({params.c}){code}"
			
			out = @params.jsdoc() + out

			return out

		var func = "({params.c})" + code
		var ctx = context

		if target
			if fname[0] == '['
				fname = fname.slice(1,-1)
			else
				fname = "'{fname}'"
			if isGetter
				out = "Object.defineProperty({target.c},'{fname}',\{get: {funcKeyword}{func}, configurable: true\})"
			elif isSetter
				out = "Object.defineProperty({target.c},'{fname}',\{set: {funcKeyword}{func}, configurable: true\})"
			else
				let k = OP('.',target,@name)
				out = "{k.c} = {funcKeyword} {func}"

			if o:export
				out = "exports.{o:default ? 'default' : fname} = {out}"
		else
			out = "{M funcKeyword, keyword} {M fname, @name}{func}"
			if o:export
				if STACK.cjs
					let exportName = o:default ? 'default' : fname
					out = "{out};\n{M('exports',o:export)}.{exportName} = {fname}"
				else
					out = "{M('export',o:export)} {o:default ? M('default ',o:default) : ''}{out}"

		if o:global
			out = "{out}; {scope__.root.globalRef}.{fname} = {fname};"
		
		if option(:return)
			out = "return {out}"

		return out


export class TagFragmentDeclaration < MethodDeclaration


export class PropertyDeclaration < Node
	var propTemplate = '''

	get ${getter}(){ return ${get}; }
	set ${getter}(v){ ${set}; }
	${meta}
	'''

	var propWatchTemplate = '''
	get ${getter}(){ return ${get}; }
	set ${getter}(v){
		var a = ${get};
		if(v != a) { ${set}; }
		if(v != a) { ${ondirty} }
	}
	${meta}
	'''

	prop name
	prop schema
	prop value

	def initialize name, schema, token
		@token = token
		@traversed = no
		@name = name
		@schema = schema || Obj.new(AssignList.new)

	def visit
		@decorators = up?.collectDecorators
		@name.traverse if @name and @name:traverse
		@schema.traverse
		@value = option(:value)
		# if @value
		# @value.traverse if @value
		scope__.entities.add(name,self)
		self
	
	def toJSON
		{
			type: "prop"
			name: "" + name
			desc: @desc
			loc: loc
		}
	
	def loc
		[@token.@loc,@name.region[1]]

	def storageKey
		@storageKey ||= STR(name.c + '$$')

	def isPlain
		!@decorators and (!@value or @value.isPrimitive)

	def isStatic
		option(:static)

	def isLazy
		option(:lazy)

	def getter
		@getter ||= if true
			let op = OP('.',THIS,storageKey)
			let getter = op
			if value and (!(value isa Str) and !(value isa Str) and !(value isa Bool) or @decorators)
				# and !value.isPrimitive # only strings and numbers
				let setter = OP('=',getter,value)
				# op = IF(OP('==',getter,LIT('undefined')),setter)
				op = IF(CALL(LIT('!this.hasOwnProperty'),[storageKey]),setter)
				op = METH([],[op,BR,getter])
				op.traverse
				return op
			else
				return FN([],[op])

	def setter
		@setter ||= if true
			let op = OP('=',OP('.',THIS,storageKey),LIT('value'))
			FN([LIT('value')],[op])

	def decorater
		@decorater ||= if true
			# let target = option(:static) ? LIT('this') : LIT('this.prototype')
			util.decorate(Arr.new(@decorators),target,name,LIT('null'))

	def target
		option(:static) ? LIT('this') : LIT('this.prototype')

	# This will soon support bindings / listeners etc, much more
	# advanced generated code based on options passed in.
	def c
		let up = STACK.current
		let out

		if up isa ClassBody
			return if isPlain
			let prefix = isStatic ? 'static ' : ''
			out = "{prefix}set {name}{setter.c(keyword: '')}\n{prefix}get {name}{getter.c(keyword: '')}"

		elif up isa ClassInitBlock
			if !isLazy and isPlain and value
				out = util.setField(target,name,@value).c + ';\n'
			# else
			# 	let obj = Obj.wrap(enumerable: false, writable: true, value: LIT('undefined'))
			# 	out = util.initField(target,storageKey,obj).c + ';\n'

		elif up isa InstanceInitBlock and !isStatic and !isLazy
			if value
				# out = util.setField(THIS,name,value).c + ';\n'
				out = OP('.',THIS,name).c + ';\n'

		return out

		var o = schema
		var ast = ""
		var key = name.js
		var scope = STACK.scope
		var value = option(:value)

		var addDesc = o.keys:length

		var pars = o.hash

		var isAttr = (@token and String(@token) == 'attr')
		var isNative = pars:native isa Bool ? pars:native.isTruthy : undefined

		var js =
			key: key
			getter: key
			scope: "{scope.context.c}"
			path: '${scope}.prototype'
			set: "this.__{key} = v"
			get: "this.__{key}"
			init: ""
			headers: ""
			ondirty: ""

		var tpl = propTemplate

		o.add('name',Symbol.new(key))

		if pars:watch
			tpl = propWatchTemplate unless pars:watch isa Bool and !pars:watch.isTruthy
			var wfn = "{key}DidSet"

			if pars:watch isa Symbol
				wfn = pars:watch
			elif pars:watch isa Str
				wfn = pars:watch
			elif pars:watch isa Bool
				o.key(:watch).value = Symbol.new("{key}DidSet")
			else
				wfn = null

			if wfn
				let fn = OP('.',This.new,wfn)
				js:ondirty = OP('&&',fn,CALL(fn,['v','a',"this.__{key}"])).c
			else
				js:ondirty = "{scope__.imba.c}.propDidSet(this,this.__{key},v,a)"

		if isAttr # (@token and String(@token) == 'attr') or o.key(:dom) or o.key(:attr)
			js:set = 'this.setAttribute("${key}",v,${desc})'
			js:get = 'this.getAttribute("${key}",${desc})'

		elif o.key(:delegate)
			# if we have a delegate
			js:set = "v = this.__{key}.delegate.set('{key}',v,this,$\{desc\})"
			js:get = "this.__{key}.delegate.get('{key}',this,$\{desc\})"

		if pars:get isa Str
			js:get = "this.{pars:get.raw}()"

		if pars:set isa Str
			js:set = "this.{pars:set.raw}(v)"

		if pars:default
			# how can we support this with new syntax?
			js:init = "{js:path}._{key} = {pars:default.c};"

		js:options = o.c

		if addDesc
			let tmpvar = scope__.root.declare(null,o)
			js:desc = tmpvar.c
			js:meta = 'get ___${key}(){ return ${desc} }'

		var reg = /\$\{(\w+)\}/gm
		# var tpl = o.key(:watch) ? propWatchTemplate : propTemplate
		var out = tpl.replace(reg) do |m,a| js[a] or ''
		# run another time for nesting. hacky
		out = out.replace(reg) do |m,a| js[a] or ''
		# out = out.replace(/\n\s*$/,'')
		out = out.replace(/^\s+|\s+$/g, '')

		if option(:static)
			out = out.replace(/^([\s\t]*)(get|set) /mg) do |m,pre,typ|
				"{pre}static {typ} "
		# if o.key(:v)
		return out



# Literals should probably not inherit from the same parent
# as arrays, tuples, objects would be better off inheriting
# from listnode.

export class Literal < ValueNode

	def initialize v
		@traversed = no
		@expression = yes
		@cache = null
		@raw = null
		@value = load(v)
		
	def load value
		value
		

	def toString
		"" + value

	def hasSideEffects
		false

	def shouldParenthesizeInTernary
		no

	def startLoc
		@startLoc or (@value:startLoc && @value.startLoc)

	def endLoc
		@endLoc or (@value:endLoc && @value.endLoc)

export class RawScript < Literal

	def c
		@value

export class Bool < Literal

	# Should keep the real value (yes/no/true/false)?
	def initialize v
		@value = v
		@raw = String(v) == "true" ? true : false

	def cache
		self

	def isPrimitive
		yes

	def truthy
		String(value) == "true"
		# yes

	def js o
		String(@value)

	def c
		STACK.@counter += 1
		# undefined should not be a bool
		String(@value)
		# @raw ? "true" : "false"

	def toJSON
		{type: 'Bool', value: @value}

	def loc
		@value:region ? @value.region : [0,0]

export class Undefined < Literal

	def isPrimitive
		yes

	def isTruthy
		no

	def c
		M("undefined",@value)

export class Nil < Literal

	def isPrimitive
		yes

	def isTruthy
		no

	def c
		M("null",@value)

export class True < Bool

	def raw
		true

	def isTruthy
		yes

	def c
		M("true",@value)

export class False < Bool

	def raw
		false

	def isTruthy
		no

	def c
		M("false",@value)

export class Num < Literal

	# value is token - should not be
	def initialize v
		@traversed = no
		@value = v

	def toString
		String(@value)

	def toNumber
		parseFloat(String(@value))

	def isPrimitive deep
		yes

	def isTruthy
		String(@value) != "0"

	def shouldParenthesize par = up
		par isa Access and par.left == self

	def js o
		var num = String(@value)
		return num

	def c o
		return super(o) if @cache
		var out = M(String(@value),@value)
		var par = STACK.current
		var paren = par isa Access and par.left == self
		# only if this is the right part of the access
		paren ? "({out})" : out

	def cache o
		return self unless o and (o:cache or o:pool)
		super(o)

	def raw
		# really?
		JSON.parse(String(value))

	def toJSON
		{type: typeName, value: raw}

# should be quoted no?
# what about strings in object-literals?
# we want to be able to see if the values are allowed
export class Str < Literal

	def initialize v
		@traversed = no
		@expression = yes
		@cache = null
		@value = v
		# should grab the actual value immediately?

	def isString
		yes

	def isPrimitive deep
		yes

	def raw
		# JSON.parse requires double-quoted strings,
		# while eval also allows single quotes.
		# NEXT eval is not accessible like this
		# WARNING TODO be careful! - should clean up

		@raw ||= String(value).slice(1,-1) # incredibly stupid solution

	def isValidIdentifier
		# there are also some values we cannot use
		raw.match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? true : false

	def js o
		String(@value)

	def c o
		@cache ? super(o) : (M js, @value)

export class TemplateString < ListNode

	def js
		let parts = @nodes.map do |node|
			node isa String ? node : node.c()

		let out = '`' + parts.join('') + '`'
		return out

export class Interpolation < ValueNode

# Currently not used - it would be better to use this
# for real interpolated strings though, than to break
# them up into their parts before parsing
export class InterpolatedString < Node

	def initialize nodes, o = {}
		@nodes = nodes
		@options = o
		self

	def add part
		@nodes.push(part) if part
		self

	def visit
		for node in @nodes
			node.traverse
		self
		
	def isString
		yes

	def escapeString str
		str = str.replace(/\n/g, '\\\n')

	def js o
		var kind = String(option("open") or '"')
		# creating the string
		var parts = []
		var str = @noparen ? '' : '('

		@nodes.map do |part,i|
			if part isa Token and part.@type == 'NEOSTRING'
				# esca
				parts.push(kind + escapeString(part.@value) + kind)
			elif part
				if i == 0
					# force first part to be string
					parts.push('""')
				part.@parens = yes
				parts.push(part.c(expression: yes))

		str += parts.join(" + ")
		str += ')' unless @noparen
		return str

# Because we've dropped the Str-wrapper it is kinda difficult
export class Symbol < Literal

	def isValidIdentifier
		raw.match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? true : false

	def isPrimitive deep
		yes

	def raw
		@raw ||= AST.sym(value.toString.replace(/^\:/,''))

	def js o
		"'{AST.sym(raw)}'"

export class RegExp < Literal

	def isPrimitive
		yes

	def js
		var v = super
		
		# special casing heregex
		if var m = constants.HEREGEX.exec(v)
			# console.log 'matxhed heregex',m
			var re = m[1].replace(constants.HEREGEX_OMIT, '').replace(/\//g, '\\/')
			return '/' + (re or '(?:)') + '/' + m[2]
		
		v == '//' ? '/(?:)/' : v

# Should inherit from ListNode - would simplify
export class Arr < Literal

	def load value
		value isa Array ? ArgList.new(value) : value

	def push item
		value.push(item)
		self

	def count
		value:length

	def nodes
		var val = value
		val isa Array ? val : val.nodes

	def splat
		value.some(|v| v isa Splat)

	def visit
		@value.traverse if @value and @value:traverse
		self

	def isPrimitive deep
		!value.some(|v| !v.isPrimitive(yes) )

	def js o
		var val = @value
		return "[]" unless val
		var nodes = val isa Array ? val : val.nodes
		var out = val isa Array ? AST.cary(val) : val.c
		"[{out}]"

	def hasSideEffects
		value.some(|v| v.hasSideEffects )

	def toString
		"Arr"

	def indented a,b
		@value.indented(a,b)
		self

	def self.wrap val
		Arr.new(val)

# should not be cklassified as a literal?
export class Obj < Literal

	def load value
		value isa Array ? AssignList.new(value) : value

	def visit
		@value.traverse if @value
		# for v in value
		# 	v.traverse
		self

	def isPrimitive deep
		!value.some(|v| !v.isPrimitive(yes) )

	def js o
		var dyn = value.filter(|v| v isa ObjAttr and (v.key isa Op or v.key isa InterpolatedString)  )

		if dyn:length > 0
			var idx = value.indexOf(dyn[0])
			# create a temp variable

			var tmp = scope__.temporary(self)
			# set the temporary object to the same
			var first = value.slice(0,idx)
			var obj = Obj.new(first)
			var ast = [OP('=',tmp,obj)]

			value.slice(idx).forEach do |atr|
				ast.push(OP('=',OP('.',tmp,atr.key),atr.value))
			ast.push(tmp) # access the tmp at in the last part
			return Parens.new(ast).c

		# for objects with expression-keys we need to think differently
		'{' + value.c + '}'

	def add k, v
		k = Identifier.new(k) if k isa String or k isa Token
		var kv = ObjAttr.new(k,v)
		value.push(kv)
		return kv

	def remove key
		for k in value
			value.remove(k) if k.key.symbol == key
		self

	def keys
		Object.keys(hash)

	def hash
		var hash = {}
		for k in value
			hash[k.key.symbol] = k.value if k isa ObjAttr
		return hash
		# return k if k.key.symbol == key

	# add method for finding properties etc?
	def key key
		for k in value
			return k if k isa ObjAttr and k.key.symbol == key
		null

	def indented a,b
		@value.indented(a,b)
		self

	def hasSideEffects
		value.some(|v| v.hasSideEffects )

	# for converting a real object into an ast-representation
	def self.wrap obj
		var attrs = []
		for own k,v of obj
			if v isa Array
				v = Arr.wrap(v)
			elif v:constructor == Object
				v = Obj.wrap(v)
			# if k isa String
			#	k = LIT(k)
			v = NODIFY(v)

			if k isa String
				k = Identifier.new(k)

			attrs.push(ObjAttr.new(k,v))
		return Obj.new(attrs)

	def toString
		"Obj"

export class ObjAttr < Node

	prop key
	prop value
	prop options

	def initialize key, value, defaults
		@traversed = no
		@key = key
		@value = value
		@dynamic = key isa Op
		@defaults = defaults
		self

	def visit stack, state
		# should probably traverse key as well, unless it is a dead simple identifier
		key.traverse
		value.traverse if value
		@defaults.traverse if @defaults
		
		let decl = state && state:declaring

		if key isa Ivar
			if !value
				key = Identifier.new(key.value)
				value = OP('.',scope__.context,key)
				if @defaults
					value = OP('=',value,@defaults)
					@defaults = null

		elif key isa Private
			if !value
				value = OP('.',scope__.context,key)
				key = Identifier.new(key.value)

		elif key isa Identifier
			# if state && state:declaring
			# 	key.variable = scope__.register(key.symbol,key)\
			# isnt this rather going to
			
			if !value
				if decl
					value = scope__.register(key.symbol,key, type: decl)
					if @defaults
						value = OP('=',value,@defaults)
						@defaults = null
				else
					value = scope__.lookup(key.symbol)
					
		self

	def js o
		let key = self.key
		let kjs

		# if key isa Identifier and String(key.@value)[0] == '@'
		# 	key = Ivar.new(key)

		if key isa IdentifierExpression
			# streamline this interface
			kjs = key.asObjectKey
		elif key.isReserved
			kjs = "'{key.c}'"
		else
			kjs = key.c

		# var k = key.isReserved ? "'{key.c}'" : key.c

		if @defaults
			"{kjs} = {@defaults.c}"
		elif value
			"{kjs}: {value.c}"
		else
			"{kjs}"

	def hasSideEffects
		true

	def isPrimitive deep
		!@value or @value.isPrimitive(deep)


export class ArgsReference < Node

	# should register in this scope --
	def c
		"arguments"

# should be a separate Context or something
export class Self < Literal

	def initialize value
		@value = value

	def cache
		self

	def reference
		return self

	def visit
		scope__.context
		self

	def c
		var s = scope__
		M((s ? s.context.c : "this"),@value)

export class This < Self

	def cache
		self

	def reference
		self

	def visit
		self

	def c
		M("this",@value)

# OPERATORS

export class Op < Node

	prop op
	prop left
	prop right

	def initialize o, l, r
		# set expression yes, no?
		@expression = no
		@traversed = no
		@parens = no
		@cache = null
		@invert = no
		@opToken = o
		@op = o and o.@value or o
		
		if @op == 'and'
			@op = '&&'
		elif @op == 'or'
			@op = '||'
		elif @op == 'is'
			@op = '==='
		elif @op == 'isnt'
			@op = '!=='
		elif @op == 'not'
			@op = '!'
			
		@left = l
		@right = r
		return self

	def visit
		@right.traverse if @right
		@left.traverse if @left
		return self

	def isExpressable
		# what if right is a string?!?
		!right || right.isExpressable

	def startLoc
		let l = @left
		l and l:startLoc ? l.startLoc : super

	def js o
		var out = null
		var op = @op

		var l = @left
		var r = @right

		l = l.c if l isa Node
		r = r.c if r isa Node

		if l && r
			out = "{l} {M op,@opToken} {r}"
		elif l
			out = "{M op,@opToken}{l}"
		# out = out.parenthesize if up isa Op # really?
		out
		
	def isString
		@op == '+' and @left and @left.isString

	def shouldParenthesize
		@parens
		# option(:parens)

	def precedence
		10

	def consume node
		return super if isExpressable

		# TODO can rather use global caching?
		var tmpvar = scope__.declare(:tmp,null,system: yes)
		var clone = OP(op,left,null)
		var ast = right.consume(clone)
		ast.consume(node) if node
		return ast

export class ComparisonOp < Op

	def invert
		# are there other comparison ops?
		# what about a chain?
		var op = @op
		var pairs = [ "==","!=" , "===","!==" , ">","<=" , "<",">=" ]
		var idx = pairs.indexOf(op)
		idx += (idx % 2 ? -1 : 1)
		self.op = pairs[idx]
		@invert = !@invert
		self

	def c
		if left isa ComparisonOp
			left.right.cache
			OP('&&',left,OP(op,left.right,right)).c
		else
			super

	def js o
		var op = @op
		var l = @left
		var r = @right

		l = l.c if l isa Node
		r = r.c if r isa Node
		return "{l} {M op,@opToken} {r}"


export class UnaryOp < Op

	def invert
		if op == '!'
			return left
		else
			super # regular invert

	def isTruthy
		var val = AST.truthy(left)
		return val !== undefined ? (!val) : (undefined)

	def startLoc
		let l = (@left or @op)
		l and l:startLoc ? l.startLoc : @startLoc

	def js o
		var l = @left
		var r = @right
		var op = op

		if op == 'not'
			op = '!'

		if op == '!'
			# l.@parens = yes
			var str = l.c
			var paren = l.shouldParenthesize(self)
			# FIXME this is a very hacky workaround. Need to handle all this
			# in the child instead, problems arise due to automatic caching
			str = '(' + str + ')' unless str.match(/^\!?([\w\.]+)$/) or l isa Parens or paren or l isa Access or l isa Call
			# l.set(parens: yes) # sure?
			"{op}{str}"

		elif left
			"{l.c}{op}"

		else
			"{op}{r.c}"

	def normalize
		return self if op == '!'
		var node = (left || right).node
		# for property-accessors we need to rewrite the ast
		return self

		return self unless node isa PropertyAccess

		# ask to cache the path
		node.left.cache if node isa Access && node.left

		var num = Num.new(1)
		var ast = OP('=',node,OP(op[0],node,num))
		ast = OP(op[0] == '-' ? '+' : '-',ast,num) if left

		return ast

	def consume node
		var norm = normalize
		norm == self ? super : norm.consume(node)

	def c
		var norm = normalize
		norm == self ? super : norm.c

export class InstanceOf < Op

	def js o
		# fix checks for String and Number

		if right isa Identifier or right isa VarOrAccess
			# WARN otherwise - what do we do? does not work with dynamic
			# classes etc? Should probably send to utility function isa$
			var name = AST.c(right.value)
			var obj = left.node
			# TODO also check for primitive-constructor
			if name in ['String','Number','Boolean']
				if STACK.tsc
					return "(typeof {obj.c}=='{name.toLowerCase}')"

				unless obj isa LocalVarAccess
					obj.cache
				# need a double check for these (cache left) - possibly
				return "(typeof {obj.c}=='{name.toLowerCase}'||{obj.c} instanceof {name})"

				# convert
		var out = "{left.c} instanceof {right.c}"

		# should this not happen in #c?
		out = helpers.parenthesize(out) if o.parent isa Op
		out

export class TypeOf < Op

	def js o
		"typeof {left.c}"

export class Delete < Op

	def js o
		# TODO this will execute calls several times if the path is not directly to an object
		# need to cache the receiver
		var l = left
		var tmp = scope__.temporary(self, pool: 'val')
		var o = OP('=',tmp,l)
		# FIXME
		return "({o.c},delete {l.c}, {tmp.c})" # oh well
		# var ast = [OP('=',tmp,left),"delete {left.c}",tmp]
		# should parenthesize directly no?
		# ast.c

	def shouldParenthesize
		yes

export class In < Op

	def invert
		@invert = !@invert
		self

	def js o
		var cond = @invert ? "== -1" : ">= 0"
		var idx = Util.indexOf(left,right)
		"{idx.c} {cond}"



# ACCESS

export class Access < Op

	def initialize o, l, r
		# set expression yes, no?
		@expression = no
		@traversed = no
		@parens = no
		@cache = null
		@invert = no
		@op = o and o.@value or o
		@left = l
		@right = r
		return self

	def startLoc
		(@left or @right).startLoc

	def endLoc
		@right && @right.endLoc

	def clone left, right
		var ctor = self:constructor
		ctor.new(op,left,right)

	def js o
		var raw = null
		var lft = left
		var rgt = right

		if rgt isa Token
			rgt = Identifier.new(rgt)

		var ctx = (lft || scope__.context)
		var pre = ""
		var mark = ''

		unless @startLoc
			@startLoc = (lft or rgt).startLoc

		if lft isa Super and STACK.method and STACK.method.option('inExtension')
			return CALL(
				OP('.',scope__.context,'super$'),
				[rgt isa Identifier ? rgt.toStr : rgt]
			).c()

		if rgt isa Num
			return ctx.c + "[" + rgt.c + "]"

		# is this right? Should not the index compile the brackets
		# or value is a symbol -- should be the same, no?
		if rgt isa Index and (rgt.value isa Str or rgt.value isa Symbol)
			rgt = rgt.value

		# TODO do the identifier-validation in a central place instead
		if rgt isa Str and rgt.isValidIdentifier
			raw = rgt.raw

		elif rgt isa Symbol and rgt.isValidIdentifier
			raw = rgt.raw

		elif rgt isa Identifier and rgt.isValidIdentifier
			# raw = M(rgt.c,rgt)
			raw = rgt.c

		if safechain and ctx
			ctx.cache(force: yes)
			pre = ctx.c + " && "

		# really?
		# var ctx = (left || scope__.context)
		var out = if raw
			# see if it needs quoting
			# need to check to see if it is legal
			ctx ? "{ctx.c}.{raw}" : raw
		else
			var r = rgt isa Node ? rgt.c(expression: yes) : rgt
			"{ctx.c}[{r}]"

		# if safechain and ctx
		# 	out = "{ctx.c} && {out}"

		out = pre + out
		return out

	def visit
		left.traverse if left
		right.traverse if right
		return

	def isExpressable
		true

	def alias
		right isa Identifier ? right.alias : super()

	def safechain
		# right.safechain
		String(@op) == '?.' or String(@op) == '?:'

	def cache o
		(right isa Ivar && !left) ? self : super(o)

	def shouldParenthesizeInTernary
		@parens or @cache


# Should change this to just refer directly to the variable? Or VarReference
export class LocalVarAccess < Access

	prop safechain

	def js o
		if right isa Variable and right.type == 'meth'
			return "{right.c}()" unless up isa Call

		right.c

	def variable
		right

	def cache o = {}
		super(o) if o:force
		self

	def alias
		variable.@alias or super()



export class PropertyAccess < Access

	def initialize o, l, r
		@traversed = no
		@invert = no
		@parens = no
		@expression = no # yes?
		@cache = null
		@op = o
		@left = l
		@right = r
		return self

	def visit
		@right.traverse if @right
		@left.traverse if @left
		return self

	# right in c we should possibly override
	# to create a call and regular access instead

	def js o
		# if var rec = receiver
		# 	var ast = CALL(OP('.',left,right),[]) # convert to ArgList or null
		# 	ast.receiver = rec
		# 	return ast.c

		var up = up
		# really need to fix this - for sure
		# should be possible for the function to remove this this instead?
		var js = "{super(o)}"
		return js


	def receiver
		if left isa Super
			SELF
		else
			null

export class IvarAccess < Access

	def visit
		@right.traverse if @right
		@left ? @left.traverse : scope__.context
		return self

	def cache
		# WARN hmm, this is not right... when accessing on another object it will need to be cached
		return self



export class IndexAccess < Access

	def cache o = {}
		return super if o:force
		right.cache
		self


export class VarOrAccess < ValueNode

	def initialize value
		# should rather call up to valuenode?
		@traversed 	= no
		@parens 	= no
		@value 		= value
		@identifier = value
		@token 		= value.@value
		@variable = null
		self

	def startLoc
		@token.startLoc

	def endLoc
		@token.endLoc

	# Shortcircuit traverse so that it is not added to the stack?!
	def visit stack, state
		# @identifier = value # this is not a real identifier?
		var variable
		var scope = scope__
		
		if state && state:declaring
			# console.log "VarOrAccess {@identifier}"
			variable = scope.register(value,self,type: state:declaring)

		

		variable ||= scope.lookup(value)

		# does not really need to have a declarator already? -- tricky
		if variable && variable.declarator
			# var decl = variable.declarator
			let vscope = variable.scope

			# if the variable is not initialized just yet and we are
			# in the same scope - we should not treat this as a var-lookup
			# ie.  var x = x would resolve to var x = this.x() if x
			# was not previously defined
			if vscope == scope and !variable.@initialized
				
				# here we need to check if the variable exists outside
				# if it does - we need to ensure that the inner variable does not collide
				let outerVar = scope.parent.lookup(value)
				if outerVar
					variable.@virtual = yes
					variable.@shadowing = outerVar
					variable = outerVar

			# should do this even if we are not in the same scope?
			# we only need to be in the same closure(!)

			if variable and variable.@initialized or (scope.closure != vscope.closure)
				@variable = variable
				variable.addReference(self)
				@value = variable # variable.accessor(self)
				@token.@variable = variable
				
				# if vscope isa RootScope and vscope.context != scope.context and variable.type == 'meth'
				# 	warn "calling method from root scope {value} is deprecated - see issue #112"
				return self

			# FIX
			# @value.safechain = safechain
		return self

	def c
		@variable ? super() : @identifier.c() # M(@token.value,@token)
		# M((@variable ? super() : value.c), @token)

	def js o
		if var v = @variable
			return v.c()
		throw 'not implemented'

	def node
		@variable ? self : value

	def symbol
		@identifier.symbol
		# value and value.symbol

	def cache o = {}
		@variable ? (o:force and super(o)) : value.cache(o)

	def decache
		@variable ? super() : value.decache
		self

	def dom
		value.dom

	def safechain
		@identifier.safechain

	def dump
		{ loc: loc }

	def loc
		var loc = @identifier.region
		return loc or [0,0]

	def region
		@identifier.region

	def shouldParenthesizeInTernary
		@cache or (@value and @value.@cache) or @parens

	def toString
		"VarOrAccess({value})"

	def toJSON
		{type: typeName, value: @identifier.toString}

#	def js
#		if right isa Variable and right.type == 'meth'
#			return "{right.c}()" unless up isa Call
#
#		right.c
#
#	def variable
#		right
#
#	def cache o = {}
#		super if o:force
#		self
#
#	def alias
#		variable.@alias or super # if resolved?
#

export class VarReference < ValueNode

	prop variable
	prop declared
	prop type

	def initialize value, type
		if value isa VarOrAccess
			value = value.value
			@variable = null
		elif value isa Variable
			@variable = value
			value = ""

		# for now - this can happen
		super(value)
		@export = no
		@type = type and String(type)
		@declared = yes # just testing now


	def loc
		@value.region

	def declare
		self

	def consume node
		# really? the consumed node dissappear?
		@variable && @variable.autodeclare
		self

	def visit stack, state
		var vars = []
	
		@value.traverse(declaring: @type, variables: vars)

		if @value isa Identifier
			@value.@variable ||= scope__.register(@value.symbol,self,type: @type)
			vars.push(@value.@variable)

		for variable in vars
			# should always be autodeclared?
			variable.@virtual = yes
			variable.autodeclare()

		return self
	
	def js o
		return @value.c()


# ASSIGN

export class Assign < Op

	def initialize o, l, r
		# set expression yes, no?
		@expression = no
		@traversed = no
		@parens = no
		@cache = null
		@invert = no
		@opToken = o
		@op = o and o.@value or o
		@left = l
		@right = r
		return self

	def isExpressable
		!right || right.isExpressable

	def isUsed
		# really?
		# if up is a block in general this should not be used -- since it should already have received implicit self?
		if up isa Block # && up.last != self
			return no
		return yes

	# FIXME optimize
	def visit
		var l = @left
		var r = @right
		
		if r
			r.traverse(assignment: yes)
	
		if l
			l.traverse()

		return self

	def c o
		unless right.isExpressable
			if left isa VarReference and left.type == 'let'
				# when does this occur?
				# console.log 'unexpressable let var assignment'
				return Block.new([left,BR,right.consume(self)]).c(o)
			return right.consume(self).c(o)
		# testing this
		return super(o)

	def js o
		unless right.isExpressable
			p "Assign#js right is not expressable "
			# here this should be go out of the stack(!)
			# it should already be consumed?
			return right.consume(self).c
		var l = left.node
		var r = right

		if l isa Access and l.left isa Super
			if let m = STACK.method
				if m.option('inExtension')
					let key = l.right
					key = key.toStr if key isa Identifier
					# return "{scope.__context.c}.super$set('{l.right.c}')"
					let op = CALL(
						OP('.',scope__.context,'super$set'),
						[key,right]
					)
					return op.c(expression: true)
		# We are setting self(!)
		# TODO document functionality
		if l isa Self
			var ctx = scope__.context
			l = ctx.reference

		var lc = l.c
		var out = "{lc} {op} {right.c(expression: true)}"
		
		if let typ = (option(:datatype) or l.option(:datatype))
			if STACK.tsc and !(l isa VarReference)
				out = '/** @type {' + typ.c() + '} */\n' + out

		if l isa Obj
			out = "({out})"

		return out

	# FIXME op is a token? _FIX_
	# this (and similar cases) is broken when called from
	# another position in the stack, since 'up' is dynamic
	# should maybe freeze up?
	def shouldParenthesize par = up
		@parens or par isa Op && par.op != '='

	def consume node
		if node isa TagLike
			if right isa TagLike
				right.set(assign: left)
				return right.consume(node)
			else
				return self

		if isExpressable
			forceExpression
			return super(node)

		var ast = right.consume(self)
		return ast.consume(node)


export class PushAssign < Assign
	
	prop consumed
	
	def register node
		@consumed ||= []
		@consumed.push(node)
		self
		
	def js o
		"{left.c}.push({right.c})"

	def consume node
		return self

export class TagPushAssign < PushAssign

	def js o
		"{left.c}.push({right.c})"

	def consume node
		return self


export class ConditionalAssign < Assign

	def consume node
		normalize.consume(node)

	def normalize
		var l = left.node
		var ls = l

		if l isa Access

			if l.left
				l.left.cache
			ls = l.clone(l.left,l.right) # this should still be cached?

			if l isa PropertyAccess # correct now, to a certain degree
				l.cache

			if l isa IndexAccess or l.right isa IdentifierExpression
				l.right.cache

			# we should only cache the value itself if it is dynamic?
			# l.cache # cache the value as well -- we cannot use this in assigns them

		# some ops are less messy
		# need op to support consume then?
		var expr = right.isExpressable
		var ast = null
		# here we should use ast = if ...
		if expr && op == '||='
			ast = OP('||',l, OP('=',ls,right))
		elif expr && op == '&&='
			ast = OP('&&',l, OP('=',ls,right))
		else
			ast = IF(condition, OP('=',ls,right), l) # do we need a scope for these?
			ast.scope = null
			# drop the scope
			# touch scope -- should probably visit the whole thing?
			# ast.scope.visit
		ast.toExpression if ast.isExpressable
		ast


	def c
		# WARN what if we return the same?
		normalize.c

	def condition

		# use switch instead to cache op access
		if op == '?='
			OP('==',left,NULL)
		elif op == '||='
			OP('!',left)
		elif op == '&&='
			left
		elif op == '!?='
			OP('!=',left,NULL)
		else
			left

	def js o
		var ast = IF(condition, OP('=',left,right), left)
		ast.scope = null # not sure about this
		ast.toExpression if ast.isExpressable # forced expression already
		return ast.c

export class CompoundAssign < Assign

	# FIXME can we merge consume and js?
	def consume node
		return super if isExpressable

		var ast = normalize
		return ast.consume(node) unless ast == self

		ast = right.consume(self)
		return ast.consume(node)

	def normalize
		var ln = left.node
		# we dont need to change this at all
		unless ln isa PropertyAccess
			return self

		ln.left.cache if ln.left
		# TODO FIXME we want to cache the context of the assignment
		var ast = OP('=',left,OP(op[0],left,right))
		ast.toExpression if ast.isExpressable

		return ast

	def c
		var ast = normalize
		return super if ast == self

		# otherwise it is important that we actually replace this node in the outer block
		# whenever we normalize and override c it is important that we can pass on caching
		# etc -- otherwise there WILL be issues.
		var up = STACK.current
		if up isa Block
			# an alternative would be to just pass
			up.replace(self,ast)
		ast.c


export class TypeAnnotation < Node
	
	def initialize value
		@parts = value
		# @parts.push(value) if value
		self
		
	def add item
		@parts.push(item)
	
	def startLoc
		@parts[0].startLoc

	def endLoc
		@parts[@parts:length - 1].endLoc

	def c
		M(@parts.map(|item| item.@value).join(""),self)
		
# IDENTIFIERS

# really need to clean this up
# Drop the token?
export class Identifier < Node

	prop safechain
	prop value
	prop variable

	def initialize value
		if value isa Token
			@startLoc = value.startLoc
		@value = load(value)
		@symbol = null


		if ("" + value).indexOf("?") >= 0
			@safechain = yes
		# @safechain = ("" + value).indexOf("?") >= 0
		self

	def isStatic
		yes

	def toRaw
		@value.@value or @value

	def add part
		IdentifierExpression.new(self).add(part)

	def references variable
		@value.@variable = variable if @value
		self

	def load v
		return (v isa Identifier ? v.value : v)

	def traverse
		# NODES.push(self)
		self

	def visit

		if @value isa Node
			# console.log "IDENTIFIER VALUE IS NODE"
			@value.traverse
		self

	def region
		[@value.@loc,@value.@loc + @value.@len]

	def startLoc
		@value and @value:startLoc ? @value.startLoc : null

	def endLoc
		@value and @value:endLoc ? @value.endLoc : null
		
	def loc
		[startLoc,endLoc]

	def isValidIdentifier
		yes

	def isReserved
		@value:reserved or RESERVED_TEST.test(String(@value))

	def symbol
		@symbol ||= AST.sym(value)

	def toString
		String(@value)

	def toStr
		return Str.new("'" + symbol + "'")

	def toJSON
		toString

	def alias
		AST.sym(@value)

	def js o
		@variable ? @variable.c() : symbol

	def c o
		let up = STACK.current
		return toStr.c if (up isa Util and !(up isa Util.Iterable)) # not all utils
		let out = js
		if OPTS:sourceMap and (!o or o:mark !== false)
			out = M(out, @token or @value)
		return out

	def dump
		{ loc: region }

	def namepath
		toString

	def shouldParenthesizeInTernary
		@parens or @cache


export class Private < Identifier

	def symbol
		@symbol ||= AST.sym('__' + value)

	def add part
		IdentifierExpression.new(value).add(part).set(prefix: '__', private: yes)

	# def c
	# 	let up = STACK.current
	# 	return toStr.c if up isa Util
	# 	return '' + symbol
			

export class TagIdRef < Identifier

	def initialize v
		@value = v isa Identifier ? v.value : v
		self

	def c
		"{scope__.imba.c}.getTagSingleton('{value.c.substr(1)}')"


# This is not an identifier - it is really a string
# Is this not a literal?

# FIXME Rename to IvarLiteral? or simply Literal with type Ivar
export class Ivar < Identifier

	def initialize v
		@value = v isa Identifier ? v.value : v
		self

	def name
		helpers.dashToCamelCase(@value).replace(/^[@\#]/,'')
		# value.c.camelCase.replace(/^@/,'')

	def alias
		name

	# the @ should possibly be gone from the start?
	def js o
		return name


export class Decorator < ValueNode
	
	def visit
		@call.traverse if @call
		if option(:params)
			@params = option(:params)
			@params.traverse

		if let block = up
			block.@decorators ||= []
			block.@decorators.push(self)

	def c 
		# should return other places as well...
		return if STACK.current isa ClassBody
		let out = @value.c.slice(2)
		if @params
			out += "({@params.c(expression: yes)})"
		else
			out += "()"
		return out

# Ambiguous - We need to be consistent about Const vs ConstAccess
# Becomes more important when we implement typeinference and code-analysis
export class Const < Identifier

	def symbol
		# console.log "Identifier#symbol {value}"
		@symbol ||= AST.sym(value)

	def js o
		@variable ? @variable.c : symbol

	def traverse
		if @traversed
			return self

		@traversed = true
		var curr = STACK.current
		if !(curr isa Access) or curr.left == self
			if symbol == "Imba"
				@variable = scope__.imba
			else
				@variable = scope__.lookup(value)
		self

	def c
		if option(:export)
			"exports.{@value} = " + js
		else
			super


export class TagTypeIdentifier < Identifier

	prop name
	prop ns

	def initialize value
		@token = value
		@value = load(value)
		self

	def startLoc
		@token?.startLoc

	def endLoc
		@token?.endLoc
		

	def load val
		@str = ("" + val)
		var parts = @str.split(":")
		@raw = val
		@name = parts.pop
		@ns = parts.shift # if any?
		return @str

	def js o
		return "'" + @str + "'"

	def c
		js

	def func
		var name = @name.replace(/-/g,'_').replace(/\#/,'')
		name += "${@ns.toLowerCase}" if @ns
		name

	def nativeCreateNode
		if isSVG
			CALL(LIT('imba.document.createElementNS'),[STR("http://www.w3.org/2000/svg"),STR(name)])
		else
			CALL(LIT('imba.document.createElement'),[STR(name)])
			# LIT('document.createElementNS("http://www.w3.org/2000/svg",name)'

	def isClass
		!!@str.match(/^[A-Z]/)
		
	def isNative
		!@ns and TAG_TYPES.HTML.indexOf(@str) >= 0

	def isNativeSVG
		@ns == 'svg' and TAG_TYPES.SVG.indexOf(@str) >= 0

	def isSVG
		@ns == 'svg' or (!isNative and !@ns and TAG_TYPES.SVG.indexOf(@str) >= 0)

	def isCustom
		!isNative and !isNativeSVG

	def isComponent
		!isNative and !isNativeSVG
	
	def isSimpleNative
		isNative and !(/input|textarea|select|form|iframe/).test(@str)

	def toFunctionalType
		LIT(@str)

	def toClassName
		let str = @str
		if str == 'element'
			return 'Element'
		elif str == 'svg:element'
			return 'SVGElement'
		elif str == 'htmlelement'
			return 'HTMLElement'
		elif str == 'fragment'
			return 'DocumentFragment'

		let match = TAG_NAMES[isSVG ? "svg_{@name}" : @name]
		return match:name if match
			
		if @str == 'fragment'
			return 'DocumentFragment'
		else
			return helpers.pascalCase(@str + '-component')

	def id
		var m = @str.match(/\#([\w\-\d\_]+)\b/)
		m ? m[1] : null


	def flag
		"_" + name.replace(/--/g,'_').toLowerCase

	def sel
		".{flag}" # + name.replace(/-/g,'_').toLowerCase

	def string
		value

	def toString
		value

export class InterpolatedIdentifier < ValueNode
	def js
		"[{value.c}]"

export class Argvar < ValueNode

	def c
		# NEXT -- global.parseInt or Number.parseInt (better)
		var v = parseInt(String(value))
		# FIXME Not needed anymore? I think the lexer handles this
		return "arguments" if v == 0

		var s = scope__
		# params need to go up to the closeste method-scope
		var par = s.params.at(v - 1,yes)
		"{AST.c(par.name)}" # c


# CALL

export class Call < Node

	prop callee
	prop receiver
	prop args
	prop block

	# def m
	# 	console.log "called Call.m {@callee} ({startLoc} - {@callee.startLoc}) [{endLoc}]"
	# 	super

	def initialize callee, args, opexists
		@traversed = no
		@expression = no
		@parens = no
		@cache = null
		@receiver = null
		@opexists = opexists
		# some axioms that share the same syntax as calls will be redirected from here

		if callee isa VarOrAccess
			var str = callee.value.symbol
			if str == 'extern'
				callee.value.value.@type = 'EXTERN'
				return ExternDeclaration.new(args)
			if str == 'tag'
				# console.log "ERROR - access args by some method"
				return TagWrapper.new(args and args:index ? args.index(0) : args[0])
			if str == 'export'
				return Export.new(args)


		@callee = callee	
		@args = args or ArgList.new([])

		if args isa Array
			@args = ArgList.new(args)
			
		if callee isa Decorator
			callee.@call = self
			return callee

		return self
		
	def loc
		@callee.loc

	def visit
		args.traverse
		callee.traverse
		# if the callee is a PropertyAccess - better to immediately change it

		@block && @block.traverse

	def addBlock block
		var pos = @args.filter(|n,i| n == '&')[0] # WOULD BE TOKEN - CAREFUL
		pos ? args.replace(pos,block) : args.push(block)
		self

	def receiver
		@receiver ||= (callee isa Access && callee.left || NULL)

	# check if all arguments are expressions - otherwise we have an issue

	def safechain
		callee.safechain # really?

	def shouldParenthesizeInTernary
		@parens or safechain or @cache

	def startLoc
		@startLoc or @callee and @callee:startLoc ? @callee.startLoc : 0

	def endLoc
		@endLoc or (@args and @args.endLoc) or @callee.endLoc

	def js o
		var opt = expression: yes
		var rec = null
		# var args = AST.compact(args) # really?
		var args = args

		# drop this?

		var splat = args.some do |v| v isa Splat

		var out = null
		var lft = null
		var rgt = null
		var wrap = null

		var callee = @callee = @callee.node # drop the var or access?

		# if callee isa Call && callee.safechain
		#	yes

		if callee isa Access
			lft = callee.left
			rgt = callee.right

		if callee isa Super
			if let m = STACK.method
				# console.log "in method {m} {m.name} {m.option('inExtension')}"
				if m.option('inExtension')
					callee = OP('.',callee,m.name)
					@receiver = scope__.context
					# callee = @callee = OP('.',scope__.context,'super$')
					# args.unshift(m.name.toStr) # = ArgList.new
			# @receiver = scope__.context
			self
			# return "supercall"

		# never call the property-access directly?
		if callee isa PropertyAccess # && rec = callee.receiver
			@receiver = callee.receiver
			callee = @callee = Access.new(callee.op,callee.left,callee.right)
			# console.log "unwrapping the propertyAccess"

		if rgt isa Identifier and rgt.value == 'assert' and !splat
			let arg = args.first
			# if arg isa Op
			arg.option(:assertion,yes)
			args.@nodes[0] = AssertionNode.new(arg)
			# console.log "Special assert call!! {arg.c}",arg isa Op

			# rewrite a.len(..) to len$(a)

		if callee.safechain
			# Does this affect shouldParenthesizeInTernary?
			# if lft isa Call
			# if lft isa Call # could be a property access as well - it is the same?
			# if it is a local var access we simply check if it is a function, then call
			# but it should be safechained outside as well?
			# lft.cache if lft
			# the outer safechain should not cache the whole call - only ask to cache
			# the result? -- chain onto
			var isfn = Util.IsFunction.new([callee])
			wrap = ["{isfn.c}  &&  ",""]
			callee = OP('.',callee.left,callee.right)
			# callee should already be cached now -

		# should just force expression from the start, no?
		if @receiver
			# quick workaround
			@receiver.cache unless @receiver isa ScopeContext
			args.unshift(receiver)
			# should rather rewrite to a new call?
			out = "{callee.c(expression: yes)}.call({args.c(expression: yes,mark: false)})"

		else
			out = "{callee.c(expression: yes)}({args.c(expression: yes,mark: false)})"

		if wrap
			# we set the cachevar inside
			if @cache
				@cache:manual = yes
				out = "({cachevar.c}={out})"

			out = [wrap[0],out,wrap[1]].join("")

		return out




export class ImplicitCall < Call

	def js o
		"{callee.c}()"

export class New < Call

	# def startLoc
	# 	keyword ? keyword.startLoc : super

	def endLoc
		keyword and keyword.endLoc or super

	def startLoc
		null

	def js o
		var target = callee

		while target isa Access
			let left = target.left

			if (left isa PropertyAccess) or (left isa VarOrAccess)
				callee.@parens = yes
				break

			target = left

		# var out = "{M(keyword or 'new',keyword)} {callee.c}"
		var out = "{M('new',keyword)} {M(callee.c,callee)}"
		out += '()' unless o.parent isa Call
		out


export class ExternDeclaration < ListNode

	def visit
		nodes = map do |item| item.node # drop var or access really
		# only in global scope?
		var root = scope__
		for item in nodes
			var variable = root.register item.symbol, item, type: 'global'
			variable.addReference(item)
		self

	def c
		"// externs"


# FLOW

export class ControlFlow < Node

	def loc
		@body ? @body.loc : [0,0]

export class ControlFlowStatement < ControlFlow

	def isExpressable
		no


export class If < ControlFlow

	prop test
	prop body
	prop alt
	prop scope
	prop prevIf

	def self.ternary cond, body, alt
		# prefer to compile it this way as well
		var obj = If.new(cond, Block.new([body]), type: '?')
		obj.addElse Block.new([alt])
		return obj

	def addElse add
		if alt && alt isa If
			alt.addElse(add)
		else
			self.alt = add
			if add isa If
				add.prevIf = self
		self

	def initialize cond, body, o = {}
		setup
		@test = cond # (o:type == 'unless' ? UnaryOp.new('!',cond,null) : cond)
		@body = body
		@alt  = null
		@type = o:type
		invert if @type == 'unless'
		@scope = IfScope.new(self)
		self

	def loc
		@loc ||= [@type ? @type.@loc : 0,body.loc[1]]

	def invert
		if @test isa ComparisonOp
			@test = @test.invert
		else
			@test = UnaryOp.new('!',@test,null)

	def visit stack
		var alt = alt

		@scope.visit if @scope
		test.traverse if test
		
		@tag = stack.@tag

		# console.log "vars in if",Object.keys(@scope.varmap)
		# TODO deal with variable scope
		for own name, variable of @scope.varmap
			if variable.type == 'let'
				# console.log "variable virtualize"
				variable.@virtual = yes
				variable.autodeclare()

		# the let-variables declared in if(*test*) should be
		# local to the inner scope, but will technically be
		# declared in the outer scope. Must get unique name

		unless stack.isAnalyzing
			@pretest = AST.truthy(test)

			if @pretest === true
				# only collapse if condition includes compiletime flags?
				alt = @alt = null
				if test isa EnvFlag
					@preunwrap = true

			elif @pretest === false
				loc # cache location before removing body
				body = null

		body.traverse if body

		# should skip the scope in alt.
		if alt
			STACK.pop(self)
			alt.@scope ||= BlockScope.new(alt)
			alt.traverse
			STACK.push(self)

		# force it as expression?
		toExpression if @type == '?' and isExpressable
		self


	def js o
		var body = body
		# would possibly want to look up / out
		var brace = braces: yes, indent: yes

		if @pretest === true and @preunwrap
			# what if it is inside expression?
			let js = body ? body.c(braces: !!prevIf) : 'true'

			unless prevIf
				js = helpers.normalizeIndentation(js)

			if o.isExpression
				js = '(' + js + ')'

			return js

		elif @pretest === false and false
			alt.prevIf = prevIf if alt isa If
			let js = alt ? alt.c(braces: !!prevIf) : ''

			unless prevIf
				js = helpers.normalizeIndentation(js)

			return js
		

		if o.isExpression

			if test?.shouldParenthesizeInTernary
				test.@parens = yes

			var cond = test.c(expression: yes) # the condition is always an expression

			var code = body ? body.c : 'true' # (braces: yes)

			if body and body.shouldParenthesizeInTernary
				code = '(' + code + ')' # if code.indexOf(',') >= 0

			if alt
				var altbody = alt.c
				if alt.shouldParenthesizeInTernary
					altbody = '(' + altbody + ')'

				return "{cond} ? {code} : {altbody}"
			else
				# again - we need a better way to decide what needs parens
				# maybe better if we rewrite this to an OP('&&'), and put
				# the parens logic there
				# cond should possibly have parens - but where do we decide?
				if @tag
					return "{cond} ? {code} : void(0)"
				else
					return "{cond} && {code}"
		else
			# if there is only a single item - and it is an expression?
			var code = null
			var cond = test.c(expression: yes) # the condition is always an expression

			# if body.count == 1 # dont indent by ourselves?

			if body isa Block and body.count == 1 and !(body.first isa LoopFlowStatement)
				body = body.first

			# if body.count == 1
			#	p "one item only!"
			#	body = body.first

			code = body ? body.c(braces: yes) : '{}' # (braces: yes)

			# don't wrap if it is only a single expression?
			var out = "{M 'if',@type} ({cond}) " + code # ' {' + code + '}' # '{' + code + '}'
			out += " else {alt.c(alt isa If ? {} : brace)}" if alt
			out


	def shouldParenthesize
		!!@parens

	def consume node
		if node isa TagLike
			# now we are reconsuming this
			node.flag(F.TAG_HAS_BRANCHES)
				
			if node.body == self
				let branches = [@body]
				let alt = @alt
				
				while alt isa If
					branches.push(alt.@body)
					alt = alt.@alt
				
				if alt
					branches.push(alt)
				
				for block,i in branches
					node.@branches.push([])
					block.consume(node)

				return self
				
			if node isa TagLoopFragment
				if @body
					@body = @body.consume(node)

				if @alt
					@alt = @alt.consume(node)
				return self
			else
				return node.register(self)

			return self

		if node isa TagPushAssign or node isa TagFragment
			node.register(self)
			@body = @body.consume(node) if @body
			@alt = @alt.consume(node) if @alt
			return self

		# special case for If created from conditional assign as well?
		# @type == '?' and
		# ideally we dont really want to make any expression like this by default
		var isRet = node isa Return

		# might have been forced to expression already
		# if it was originally a ternary - why not
		if @expression or ((!isRet or @type == '?') and isExpressable)
			toExpression # mark as expression(!) - is this needed?
			return super(node)
		else
			@body = @body.consume(node) if @body
			@alt = @alt.consume(node) if @alt
		self


	def isExpressable
		# process:stdout.write 'x'
		var exp = (!body || body.isExpressable) && (!alt || alt.isExpressable)
		return exp



export class Loop < Statement


	prop scope
	prop options
	prop body
	prop catcher
	prop elseBody

	def loc
		var a = @options:keyword
		var b = @body

		if a and b
			# FIXME does not support POST_ variants yet
			[a.@loc,b.loc[1]]
		else
			[0,0]

	def initialize options = {}
		@traversed = no
		@options = options
		@body = null
		self

	def set obj
		@options ||= {}
		var keys = Object.keys(obj)
		for k in keys
			@options[k] = obj[k]
		self


	def addBody body
		self.body = AST.blk(body)
		self

	def addElse block
		self.elseBody = block
		self

	def isReactive
		@tag and @tag.fragment.isReactive

	def c o

		var s = stack
		var curr = s.current

		if stack.isExpression or isExpression
			# what the inner one should not be an expression though?
			# this will resut in an infinite loop, no?!?
			scope.closeScope
			var ast = CALL(FN([],[self]),[])
			return ast.c o

		elif stack.current isa Block or (s.up isa Block and s.current.@consumer == self)
			super.c o
		elif @tag
			super.c 0
		else
			scope.closeScope
			var ast = CALL(FN([],[self]),[])
			# scope.context.reference
			return ast.c o
			# need to wrap in function



export class While < Loop

	prop test

	def initialize test, opts
		@traversed = no
		@test = test
		@options = opts or {}
		@scope = WhileScope.new(self)
		# set(opts) if opts
		if option(:invert)
			# "invert test for while {@test}"
			@test = test.invert
		# invert the test


	def visit
		scope.visit
		test.traverse if test
		body.traverse if body

	def loc
		var o = @options
		helpers.unionOfLocations(o:keyword,@body,o:guard,@test)

	# TODO BUG -- when we declare a var like: while var y = ...
	# the variable will be declared in the WhileScope which never
	# force-declares the inner variables in the scope

	def consume node

		# This is never expressable, but at some point
		# we might want to wrap it in a function (like CS)
		return super if isExpressable
		var reuse = no
		# WARN Optimization - might have untended side-effects
		# if we are assigning directly to a local variable, we simply
		# use said variable for the inner res
		# if reuse
		# 	resvar = scope.declare(node.left.node.variable,Arr.new([]),proxy: yes)
		# 	node = null
		# 	p "consume variable declarator!?".cyan
		# else
		# declare the variable we will use to soak up results
		# TODO Use a special vartype for this?
		var resvar = scope.declare(:res,Arr.new([]),system: yes)
		# WHAT -- fix this --
		@catcher = PushAssign.new("push",resvar,null) # the value is not preset # what
		body.consume(@catcher) # should still return the same body

		# scope vars must not be compiled before this -- this is important
		var ast = Block.new([self,resvar.accessor]) # should be varaccess instead?
		ast.consume(node)
		# NOTE Here we can find a way to know wheter or not we even need to
		# return the resvar. Often it will not be needed
		# FIXME what happens if there is no node?!?


	def js o
		var out = "while ({test.c(expression: yes)})" + body.c(braces: yes, indent: yes) # .wrap

		if scope.vars.count > 0
			return [scope.vars.c,out]
		out



# This should define an open scope
# should rather
export class For < Loop

	def initialize o = {}
		@traversed = no
		@options = o
		@scope = ForScope.new(self)
		@catcher = null

	def loc
		var o = @options
		helpers.unionOfLocations(o:keyword,@body,o:guard,o:step,o:source)
	
	def ref
		@ref || "{@tag.fragment.cvar}.{oid}"

	def visit stack
		scope.visit

		var parent = stack.@tag

		options:source.traverse # what about awakening the vars here?
		
		# add guard to body
		if options:guard
			var op = IF(options:guard.invert,Block.wrap([ContinueStatement.new("continue")]))
			body.unshift(op,BR)

		declare
			
		# here add the things to declare
		
		if parent
			# TODO remove
			@tag = parent
			stack.@tag = self
			@level = (@tag && @tag.@level or 0) + 1

		body.traverse
		stack.@tag = parent
		self

	def isBare src
		src and src.@variable and src.@variable.@isArray

	def declare
		var o = options
		var scope = scope
		var src  = o:source
		var vars = o[:vars] = {}
		var oi   = o:index

		var bare = isBare(src)

		# if the name parameter is array or object we move this inside?

		# what about a range where we also include an index?
		if src isa Range
			
			let from = src.left
			let to = src.right
			let dynamic = from !isa Num or to !isa Num

			if to isa Num
				vars:len = to
			else
				# vars:len = scope.vars.push(vars:index.assignment(src.left))
				# vars:len = to.cache(force: yes, pool: 'len').predeclare
				vars:len = scope.declare('len',to,type: 'let')
				# to.cache(force: yes, pool: 'len').predeclare
				
			# scope.vars.push(vars:index.assignment(src.left))
			vars:value = scope.declare(o:name,from,type: 'let')
			vars:value.addReference(o:name) if o:name
			
			if o:index
				vars:index = scope.declare(o:index,0,type: 'let')
				vars:index.addReference(o:index)
			else
				vars:index = vars:value
				
			if dynamic
				vars:diff = scope.declare('rd',OP('-',vars:len,vars:value),type: 'let')

		else
			if oi
				vars:index = scope.declare(oi,0,type: 'let')
			else
				vars:index = scope.declare('i',Num.new(0),system: yes, type: 'let', pool: 'counter')

			vars:source = bare ? src : scope.declare('items',util.iterable(src),system: yes, type: 'let', pool: 'iter')
			vars:len = scope.declare('len',util.len(vars:source),type: 'let', pool: 'len', system: yes)
			
			if o:name
				body.unshift(VarDeclaration.new(o:name,OP('.',vars:source,vars:index),'let'),BR)
				
			vars:index.addReference(oi) if oi

		return self

	def consume node
		if node isa TagLike
			return node.register(self)

		if isExpressable
			return super

		if @resvar
			var ast = Block.new([self,BR,@resvar.accessor])
			ast.consume(node)
			return ast

		var resvar = null
		var reuseable = no # node isa Assign && node.left.node isa LocalVarAccess
		var assignee = null
		
		# this should be autodeclared no?
		resvar = @resvar ||= scope.register(:res,null,system: yes, type: 'var')

		@catcher = PushAssign.new("push",resvar,null) # the value is not preset
		let resval = Arr.new([])
		body.consume(@catcher) # should still return the same body
		resvar.autodeclare() # only if it is a system variable?
		
		if node isa VarDeclaration or node isa Assign
			node.right = resvar.accessor
			# let block = [self,BR,node]
			return Block.new([
				OP('=',resvar,resval)
				BR,
				self,
				BR,
				node
			])

		elif node
			let block = [OP('=',resvar,resval),BR,self,BR,resvar.accessor.consume(node)]
			return Block.new(block)

		return self

	def js o
		var vars = options:vars
		var idx = vars:index
		var val = vars:value
		var src = options:source
		
		var cond
		var final

		if src isa Range
			let a = src.left
			let b = src.right
			let inc = src.inclusive

			cond = OP(inc ? '<=' : '<',val,vars:len)
			final = OP('++',val)

			if vars:diff
				cond = If.ternary( OP('>',vars:diff,Num.new(0)), cond, OP(inc ? '>=' : '>',val,vars:len))
				final = If.ternary( OP('>',vars:diff,Num.new(0)),OP('++',val),OP('--',val))
			
			if idx and idx != val
				final = ExpressionBlock.new([final,OP('++',idx)])
			
		else
			cond = OP('<',idx,vars:len)

			if options:step
				final = OP('=',idx,OP('+',idx,options:step))
			else
				final = OP('++',idx)

		var before = ""
		var after = ""

		var code = body.c(braces: yes, indent: yes)
		var head = "{M('for',keyword)} ({scope.vars.c}; {cond.c(expression: yes)}; {final.c(expression: yes)}) "
		
		return before + head + code + after



export class ForIn < For

export class ForOf < For
	prop source

	def declare
		var o = options
		var vars = o:vars = {}
		var k
		var v

		# possibly proxy the index-variable?

		if o:own
			vars:source = o:source.@variable || scope.declare('o',o:source, system: true, type: 'let')
			o:value = o:index

			var i = vars:index = scope.declare('i',Num.new(0),system: yes, type: 'let', pool: 'counter')
			# systemvariable -- should not really be added to the map
			var keys = vars:keys = scope.declare('keys',Util.keys(vars:source.accessor),system: yes, type: 'let') # the outer one should resolve first
			var l = vars:len = scope.declare('l',Util.len(keys.accessor),system: yes, type: 'let')
			k = vars:key = scope.declare(o:name,null,type: 'let') # scope.declare(o:name,null,system: yes)
			
			if o:value isa Obj or o:value isa Arr
				body.unshift(VarDeclaration.new(o:value,OP('.',vars:source,k),'let'),BR)
				vars:value = null
			elif o:value
				v = vars:value = scope.declare(o:value,null,let: yes, type: 'let')
		
		else
			source = vars:source = STACK.tsc ? o:source : util.iterable(o:source)
			o:value = vars:value = o:name # need to visit these to declare them
			o:name.traverse(declaring: 'let')
			
			# need to declare this variable outside the for of
			if o:index
				vars:counter = scope.parent.temporary(null,{},"{o:index}$")
				body.unshift(VarDeclaration.new(o:index,OP('++',vars:counter),'let'),BR)
				self

		# TODO use util - why add references already? Ah -- this is for the highlighting
		v.addReference(o:index) if v and o:index
		k.addReference(o:name) if k and o:name

		self

	def js o
		var vars = options:vars
		var osrc = options:source
		var src = vars:source
		var k = vars:key
		var v = vars:value
		var i = vars:index

		var code
		
		if options:own
			# FIXME are we sure about this?
			if v and v.refcount > 0
				body.unshift(OP('=',v,OP('.',src,k)))

			body.unshift(OP('=',k,OP('.',vars:keys,i)))
			code = body.c(indent: yes, braces: yes) # .wrap
			var head = "{M('for',keyword)} ({scope.vars.c}; {OP('<',i,vars:len).c}; {OP('++',i).c})"
			return head + code

		else
			# compile to a naive for of loop
			code = scope.c(braces: yes, indent: yes)
			# let inCode = osrc.@variable ? src : (OP('=',src,osrc))
			# it is really important that this is a treated as a statement
			let js = "{M('for',keyword)} ({o.es5 ? 'var' : 'let'} {v.c} of {src.c(expression: yes)})" + code
			if vars:counter
				js = "{vars:counter} = 0; {js}"
			return js

	def head
		var v = options:vars
		# skipping head?
		[
			OP('=',v:key,OP('.',v:keys,v:index))
			OP('=',v:value,OP('.',v:source,v:key)) if v:value
		]

# NO NEED?
export class Begin < Block


	def initialize body
		@nodes = AST.blk(body).nodes


	def shouldParenthesize
		isExpression



export class Switch < ControlFlowStatement


	prop source
	prop cases
	prop fallback


	def initialize a,b,c
		@traversed = no
		@source = a
		@cases = b
		@fallback = c


	def visit
		c.traverse for c in cases
		fallback.visit if fallback
		source.visit if source
		return


	def consume node
		if node isa TagLike
			if node.body == self
				let branches = @cases.slice(0).concat([@fallback])
				for block,i in branches when block
					node.@branches.push([])
					block.consume(node)
				return self
			return node.register(self)
		# TODO work inside tags (like loops)
		@cases = @cases.map(|item| item.consume(node))
		@fallback = @fallback.consume(node) if @fallback
		self

	def c o
		if stack.isExpression or isExpression
			var ast = CALL(FN([],[self]),[])
			return ast.c o

		super.c(o)


	def js o
		var body = []

		for part in cases
			part.autobreak
			body.push(part)

		if fallback
			body.push("default:\n" + fallback.c(indent: yes))

		"switch ({source.c}) " + helpers.bracketize(AST.cary(body).join("\n"),yes)



export class SwitchCase < ControlFlowStatement


	prop test
	prop body


	def initialize test, body
		@traversed = no
		@test = test
		@body = AST.blk(body)
		@scope = BlockScope.new(self)

	def visit
		scope__.visit
		body.traverse

	def consume node
		body.consume(node)
		self


	def autobreak
		body.push(BreakStatement.new) unless body.last isa BreakStatement
		self


	def js o
		@test = [@test] unless @test isa Array
		var cases = @test.map do |item| "case {item.c}: "
		cases.join("\n") + body.c(indent: yes, braces: yes)



export class Try < ControlFlowStatement


	prop body
	# prop ncatch
	# prop nfinally

	def initialize body, c, f
		@traversed = no
		@body = AST.blk(body)
		@catch = c
		@finally = f


	def consume node
		@body = @body.consume(node)
		@catch = @catch.consume(node) if @catch
		@finally = @finally.consume(node) if @finally
		self


	def visit
		@body.traverse
		@catch.traverse if @catch
		@finally.traverse if @finally
		# no blocks - add an empty catch


	def js o
		var out = "try " + body.c(braces: yes, indent: yes)
		out += " " + @catch.c if @catch
		out += " " + @finally.c if @finally

		unless @catch or @finally
			out += " catch (e) \{ \}"
		out += ";"
		out



export class Catch < ControlFlowStatement

	prop body

	def initialize body, varname
		@traversed = no
		@body = AST.blk(body or [])
		@scope = CatchScope.new(self)
		@varname = varname
		self

	def consume node
		@body = @body.consume(node)
		self


	def visit
		@scope.visit
		@variable = @scope.register(@varname,self,pool: 'catchvar')
		@body.traverse


	def js o
		# only indent if indented by default?
		"catch ({@variable.c}) " + @body.c(braces: yes, indent: yes)


# repeating myself.. don't deal with it until we move to compact tuple-args
# for all astnodes


export class Finally < ControlFlowStatement

	def initialize body
		@traversed = no
		@body = AST.blk(body or [])


	def visit
		@body.traverse


	def consume node
		# swallow silently
		self


	def js o
		"finally " + @body.c(braces: yes, indent: yes)


# RANGE

export class Range < Op

	def inclusive
		op == '..'

	def c
		"range"


export class Splat < ValueNode

	def js o
		return "...{value.c}"

		var par = stack.parent
		if par isa ArgList or par isa Arr
			"Array.from({value.c})"
		else
			p "what is the parent? {par}"
			"SPLAT"

	def node
		value


# TAGS


export class IdentifierExpression < Node

	def self.wrap node
		return node
		node isa self ? node : self.new(node)

	def initialize value
		super
		@static = yes
		@nodes = [@single = value]

	def add part
		@nodes.push(part)
		@single = null
		self

	def isPrimitive
		@single and @single isa Token

	def isStatic
		isPrimitive

	def visit
		for node in @nodes when node isa Node
			node.traverse
		self

	def asObjectKey
		if isPrimitive
			"{@single.c()}"
		elif @single
			"[{@single.c()}]"
		else
			"[{asString}]"

	def startLoc
		let n = @nodes[0]
		n?.startLoc

	def endLoc
		let n = @nodes[@nodes:length - 1]
		n?.endLoc

	def asIdentifier
		@single ? "[{@single.c()}]" : "[{asString}]"

	def asString
		# what if a part is a string?	
		let s = '`'
		if option(:prefix)
			s += option(:prefix)
		for node in @nodes
			if node isa Token
				s += node.value
			else
				s += '${'
				s += node.c()
				s += '}'
		s += '`'
		return s

	def toRaw
		@single ? @single.c : ''

	def toString
		toRaw

	def js s, o = {}
		if o:as == 'string' or s.parent isa Util
			return asString
		elif o:as == 'key'
			return asObjectKey
		elif o:as == 'access'
			yes
		elif @single and @single isa Node
			return @single.c(o)
		else
			asString

export class TagPart < Node

	prop name
	prop value
	prop params
	
	def initialize value, owner
		@name = load(value)
		@tag = owner
		@chain = []
		@special = no
		@params = null
		self

	def load value
		value
		
	def isSpecial
		@special
		
	def visit
		@chain.map(|v| v.traverse )
		@value.traverse if @value
		@name.traverse if @name:traverse
		self
	
	def quoted
		@quoted ||= (@name isa IdentifierExpression ? @name.asString : helpers.singlequote(@name))
	
	def valueIsStatic
		!value or value.isPrimitive or (value isa Func and !value.nonlocals)

	def isStatic
		valueIsStatic

	def isProxy
		false
		
	def add item, type
		if type == TagArgList
			(@last or self).params = item or ListNode.new([])
		else
			@chain.push(@last = TagModifier.new(item))
		return self

	def modifiers
		@modifiers ||= TagModifiers.new(@chain).traverse
		
	def js
		""

	def ref
		"c$.{oid}"

export class TagId < TagPart

	def js
		"id={quoted}"

export class TagFlag < TagPart
	prop condition

	def value
		@name

	def isStatic
		!isConditional and (@name isa Token or @name.isStatic)

	def isConditional
		!!condition

	def js
		let val = value.c(as: 'string')
		condition ? "flags.toggle({val},{condition.c})" : "classList.add({val})"
	
export class TagSep < TagPart
	
export class TagArgList < TagPart
	
export class TagAttr < TagPart

	def isSpecial
		String(@name) == 'value'

	def startLoc
		@name?.startLoc

	def endLoc
		@value?.endLoc

	def isStatic
		super and @chain.every(do |item|
			let val = item isa Parens ? item.value : item
			val isa Func ? !val.nonlocals : val.isPrimitive
		)

	def visit
		@chain.map(|v| v.traverse )
		@value.traverse if @value
		@name.traverse if @name:traverse

		let key = @key = String(@name)
		let i = key.indexOf(':')

		if i >= 0
			@ns = key.slice(0,i)
			@key = key.slice(i + 1)

		unless @value
			@autovalue = yes
			@value = STR(key)

		if @chain:length
			@mods = {}
			for m in @chain
				@mods[m.name] = 1

		if @ns == 'bind'
			scope__.imbaDependency('internal/bind')
		self

	def ns
		@ns

	def key
		@key

	def mods
		@mods

	def nameIdentifier
		@nameIdentifier ||= Identifier.new(helpers.dashToCamelCase(key))

	def modsIdentifier
		@modsIdentifier ||= Identifier.new(helpers.dashToCamelCase(key) + '__')

	def js o
		# let mods = AST.compileRaw(@mods or null)
		let val = value.c(o)
		let bval = val
		let op = M('=',option(:op))

		if STACK.tsc
			let isAttr = key.match(/^(aria-|data-)/)
			if isAttr
				return "{@tag.tvar}.setAttribute('{key}',{val})"
			# how do we remove attribute then?
			let path = self.nameIdentifier()
			let access = "{@tag.tvar}.{M(path,@name)}"

			return "{M(access,@name)}{op}{@autovalue ? M('true',@value) : val}"

		if ns == 'css'
			"css$('{key}',{val})"
		elif ns == 'bind'
			let path = PATHIFY(value)

			if path isa Variable
				let getter = "function()\{ return {val} \}"
				let setter = "function(v$)\{ {val} = v$ \}"
				bval = "\{get:{getter},set:{setter}\}"
			elif path isa Array
				bval = "[{val[0].c(o)},{val[1].c(o)}]"

			"bind$('{key}',{bval})"
		elif key.indexOf("aria-") == 0 or (@tag and @tag.isSVG) or key == 'for'
			# how do we remove attribute then?
			if ns
				"setns$('{ns}','{key}',{val})"
			else
				"set$('{key}',{val})"
		elif key.indexOf("data-") == 0
			"dataset.{key.slice(5)}{op}{val}"
		elif key.indexOf('--') == 0
			"style.setProperty('{key}',{val})"
		else
			"{M(helpers.dashToCamelCase(key),@name)}{op}{val}"

		# elif dyn or true
		# 	"set({quoted},{val}{add})"
		# else
		# 	"{helpers.setterSym(name)}({val}{add})"
	
export class TagAttrValue < TagPart
	
	def isPrimitive
		value.isPrimitive

	def value
		name

	def js
		value.c

	def toRaw
		if value isa Str
			return value.raw
		return null

export class TagHandlerSpecialArg < ValueNode
	def isPrimitive
		yes

	def c
		"'~${value}'"

export class TagModifiers < ListNode
	
	def isStatic
		# the check should be for the params, no?
		@nodes.every(do |item|
			let val = item isa Parens ? item.value : item
			val isa Func ? !val.nonlocals : val.isPrimitive
		)

	def visit
		var keys = {}
		for node,i in nodes
			let key = String(node.name)
			if keys[key]
				node.name = key + '~' + (keys[key]++)
			else
				keys[key] = 1
		self

	def extractDynamics
		return @dynamics if @dynamics
		@dynamics = []

		for part,i in nodes when part isa TagModifier
			for param,k in part.params
				if !param.isPrimitive
					let ref = TagDynamicArg.new(param).set(
						key: KEY(part.name),
						index: k
					)
					part.params.swap(param,LIT('null'))
					@dynamics.push(ref)
		return @dynamics

	def c
		let obj = Obj.new([])
		for part in nodes
			let val = part.params ? Arr.new(part.params) : LIT('true')
			obj.add(KEY(part.name),val)
		return obj.c
		# Arr.new(@nodes).c

	
export class TagModifier < TagPart	
	prop params

	def load value
		if value isa IdentifierExpression
			return value.@single
		return value
	
	def isPrimitive
		!params or params.every do |param| param.isPrimitive
			
	def visit
		@params.traverse if @params
		# TODO support evaluated paths?
		for param in @params
			if param isa VarOrAccess
				let sym = param.@token.value
				if sym and sym[0] == '$'
					let special = TagHandlerSpecialArg.new(sym.slice(1))
					@params.swap(param,special)
			elif param isa PropertyAccess
				let out = helpers.clearLocationMarkers(param.js())
				if out[0] == '$'
					@params.swap(param,TagHandlerSpecialArg.new(out.slice(1)))

		self
		
	def js
		if params and params.count > 0
			"[{quoted},{params.c}]"
		elif params
			"[{quoted}]"
		else
			quoted

export class TagData < TagPart
	
	def value
		name

	def isStatic
		!value or value.isPrimitive
	
	def isSpecial
		true

	def isProxy
		proxyParts isa Array

	def proxyParts
		var val = value

		if val isa ArgList
			val = val.values[0]
			
		if val isa Parens
			val = val.value
		
		if val isa VarOrAccess
			val = val.@variable or val.value
		# console.log "TagData value {val}"

		if val isa Access
			let left = val.left
			let right = val.right isa Index ? val.right.value : val.right
			
			if val isa IvarAccess
				left ||= val.scope__.context
			
			return [left,right]
		return val

	def js
		var val = value

		if val isa ArgList
			val = val.values[0]
			
		if val isa Parens
			val = val.value
		
		if val isa VarOrAccess
			val = val.@variable or val.value
		# console.log "TagData value {val}"

		if val isa Access
			let left = val.left
			let right = val.right isa Index ? val.right.value : val.right
			
			if val isa IvarAccess
				left ||= val.scope__.context
			
			let pars = [left.c,right.c]
				
			if right isa Identifier
				pars[1] = "'" + pars[1] + "'"

			"bind$('data',[{pars.join(',')}])"
		else
			"data=({val.c})"

export class TagDynamicArg < ValueNode
	def c
		value.c

export class TagHandler < TagPart
	
	prop params watch: yes

	def paramsDidSet params
		@chain.push(@last = TagModifier.new('options'))
		@last.params = params

	def visit
		super

		if @name and CUSTOM_EVENTS[String(@name)]
			scope__.imbaDependency('events/' + String(@name))

	def isStatic
		let valStatic = !value or value.isPrimitive or (value isa Func and !value.nonlocals)
		# check modifiers directly?
		valStatic and @chain.every(do |item|
			let val = item isa Parens ? item.value : item
			val isa Func ? !val.nonlocals : val.isPrimitive
		)
	
	def modsIdentifier
		null
		
	def js o
		return "on$({quoted},{modifiers.c},{scope__.context.c})"


class TagLike < Node

	def initialize o = {}
		@options = o
		@flags = 0
		@tagvars = {}
		setup(o)
		self

	def body
		@body || @options:body

	def value
		@options:value

	def isReactive
		yes

	def isSVG
		@isSVG ?= (@parent ? @parent.isSVG : false)

	def parentTag
		let el = @parent
		while el and !(el isa Tag)
			el = el.@parent
		return el

	def setup
		@traversed = no
		@consumed = []
		self

	def root
		@parent ? @parent.root : self

	def register node
		if node isa If or node isa Switch
			flag(F.TAG_HAS_BRANCHES)
			node = TagSwitchFragment.new(body: node)
		elif node isa Loop
			flag(F.TAG_HAS_LOOPS)
			node = TagLoopFragment.new(body: node.body, value: node)
		elif node isa Tag
			flag(F.TAG_HAS_DYNAMIC_CHILDREN) if node.isSlot
		else
			flag(F.TAG_HAS_DYNAMIC_CHILDREN) unless node isa Str
			node = TagContent.new(value: node)

		@consumed.push(node) # why consume if node isa String?
		node.@parent = self
		return node

	def flag key
		@flags |= key

	def type
		"frag"

	def unflag key
		@flags = @flags & ~key

	def hasFlag key
		@flags & key

	def isAbstract
		true

	def isOnlyChild
		isFirstChild && isLastChild

	def isFirstChild
		hasFlag(F.TAG_FIRST_CHILD)

	def isLastChild
		hasFlag(F.TAG_LAST_CHILD)

	def isIndexed
		option(:indexed)

	def isComponent
		@kind == 'component'

	def isSelf
		type isa Self or type isa This
	
	def isShadowRoot
		@tagName and @tagName == 'shadow-root'
		
	def isSlot
		@kind == 'slot'

	def isFragment
		@kind == 'fragment'

	def hasLoops
		hasFlag(F.TAG_HAS_LOOPS)

	def hasBranches
		hasFlag(F.TAG_HAS_BRANCHES)

	def hasDynamicChildren
		hasFlag(F.TAG_HAS_DYNAMIC_CHILDREN)

	def hasDynamicFlags
		hasFlag(F.TAG_HAS_DYNAMIC_FLAGS)

	def hasNonTagChildren
		hasLoops or hasBranches or hasDynamicChildren

	def hasChildren
		@consumed:length > 0

	def tagvar name
		@tagvars[name] ||= scope__.closure.temporary(null,{reuse: yes},"{name}${tagvarprefix}")

	def tagvarprefix
		"{level}"

	def level
		@level

	def parent
		@parent ||= option(:parent)

	def fragment
		@fragment || parent

	def tvar
		@tvar or tagvar('t')

	# built variable
	def bvar
		@bvar or (@parent ? @parent.bvar : tagvar('b'))

	# cache variable
	def cvar
		@cvar or (@parent ? @parent.cvar :  tagvar('c'))

	def vvar do tagvar('v') # value variable
	def kvar do tagvar('k') # key variable

	# for tracking specific changes -- included in end
	# shuold maybe link it with built
	def dvar do tagvar('d') # value variable

	def ref
		@ref || (@cachedRef = "{parent ? parent.cvar : ''}.{oid}")

	def visit stack
		var o = @options
		var scope = @tagScope = scope__
		let prevTag = @parent = stack.@tag
		@level = (@parent && @parent.@level or 0) + 1
		stack.@tag = null

		for part in @attributes
			part.traverse

		stack.@tag = self
		
		if o:key
			o:key.traverse

		visitBeforeBody(stack)

		if body
			body.traverse

		visitAfterBody(stack)

		stack.@tag = @parent

		unless @parent
			@level = 0
			consumeChildren
			visitAfterConsumed

		self

	def visitBeforeBody
		self

	def visitAfterBody
		self

	def consumeChildren
		return if @consumed:length
		body && body.consume(self)
		let first = @consumed[0]
		let last = @consumed[@consumed:length - 1]

		# too many edgecases to really utilize this
		if !isAbstract
			first.flag(F.TAG_FIRST_CHILD) if first isa TagLike
			last.flag(F.TAG_LAST_CHILD) if last isa TagLike
				
		for item in @consumed when item isa TagLike
			item.@parent = self
			item.@level = (@level + 1)
			item.visitAfterConsumed
			item.consumeChildren

		visitAfterConsumedChildren
		self

	def visitAfterConsumedChildren
		self

	def visitAfterConsumed
		self

	def consume node
		if node isa TagLike
			return node.register(self)

		if node isa Variable
			option('assignToVar',node)
			return self

		if node isa Assign
			return OP(node.op,node.left,self)
		elif node isa Op
			return OP(node.op,node.left,self)
		elif node isa Return
			# console.log "return is consuming tag"
			option('return',yes)
			return self
		return self

export class TagContent < TagLike
	
	def vvar
		parent.vvar

	def bvar
		fragment.bvar

	def ref
		fragment.tvar

	def key
		@key ||= "{parent.cvar}.{oid}"

	def isStatic
		value isa Str or value isa Num

	def js
		let value = self.value
		let parts = []
		let isText = (value isa Str or value isa Num or value isa InterpolatedString)
		let isStatic = self.isStatic

		if STACK.tsc
			return value.c(o)

		if parent isa TagSwitchFragment or (@tvar and parent isa Tag and parent.isSlot)
			# what if it is a call?
			parts.push("{@tvar}={value.c(o)}")
			if value isa Call
				# mark parent to reset imba.ctx at the end
				parts.unshift("imba.ctx=({key}$ || ({key}$=\{_:{fragment.tvar}\}))")

		elif isOnlyChild and (value isa Str or value isa Num)
			return "{bvar} || {ref}.text$({value.c(o)})"
		elif isStatic
			return "{bvar} || {ref}.insert$({value.c(o)})"
		elif value isa InterpolatedString and isOnlyChild and !(parent isa TagSwitchFragment)
			value = value.@nodes[0] if value.@nodes:length == 1
			return "({vvar}={value.c(o)},{vvar}==={key} || {ref}.text$({key}={vvar}))"

		else
			parts.push("{vvar}={value.c(o)}")

			if value isa Call
				# mark parent to reset imba.ctx at the end
				parts.unshift("imba.ctx=({key}$ || ({key}$=\{_:{fragment.tvar}\}))")

			parts.push("{vvar}==={key} || ({key}_ = {ref}.insert$({key}={vvar},{@flags},{key}_))")

		return "(" + parts.join(',') + ')'

export class TagFragment < TagLike

export class TagSwitchFragment < TagLike
	
	def setup
		super
		@branches = []
		@inserts = []
		
	def getInsertVar index
		@inserts[index] ||= tagvar(self.oid + '$' + index)
		
	def tvar
		fragment.tvar
		
	def register node
		let res = super
		if @branches
			let curr = @branches[@branches:length - 1]
			curr && curr.push(res)
		return res
		
	def visitAfterConsumedChildren

		unless @parent isa TagSwitchFragment
			let max = self.assignChildIndices(0,self)
		return self
	
	def assignChildIndices start,root
		let nr = start
		let max = start
		for branch,i in @branches
			nr = start
			for item in branch
				if item isa TagSwitchFragment
					nr = item.assignChildIndices(nr,root)
				else
					item.@tvar = root.getInsertVar(nr)
					item.set(detached: yes)
					nr++

			if nr > max
				max = nr
		return max

	def js o
		var out = body.c(o)
		for item in @inserts
			let key = "{cvar}.{item}"
			out += "\n({key}_ = {tvar}.insert$({item},0,{key}_));"
		return out

export class TagLoopFragment < TagLike

	def isKeyed
		option(:keyed) or hasFlag(F.TAG_HAS_BRANCHES)

	def consumeChildren
		super

		# determine if the order of elements will ever change inside loop
		if @consumed.every(do $1 isa Tag and !$1.option(:key) and !$1.isDynamicType) and !hasFlag(F.TAG_HAS_BRANCHES)
			set(indexed: yes)
			# flag(F.TAG_INDEXED)
		else
			set(keyed: yes)
			# flag(F.TAG_KEYED)

	def cvar
		@cvar || tagvar('c')

	def js o

		if stack.isExpression
			return CALL(FN([],[self]),[]).c

		if STACK.tsc
			return "{tvar} = new DocumentFragment;\n{value.c(o)}"

		# if @tag and @childTags
		let iref = option(:indexed) ? LIT('imba.createIndexedFragment') : LIT('imba.createKeyedFragment')
		# should know how many inner slots this fragment has?
		let cache = parent.cvar
		let parentRef = parent isa TagSwitchFragment ? LIT('null') : fragment.tvar

		let out = ""
		out += "{tvar} = {cache}.{oid} || ({cache}.{oid} = {tvar} = {iref}({@flags},{parentRef}));\n"
		@ref = "{tvar}"
		out += "{kvar} = 0;\n"
		out += "{cvar}={tvar}.$;\n"
		out += value.c(o)
		out += ";{tvar}.end$({kvar})"
		return out

export class TagIndexedFragment < TagLike

export class TagKeyedFragment < TagLike

export class TagSlotProxy < TagLike

	def ref
		tvar

	def tagvarprefix
		oid+'S'


export class Tag < TagLike
	prop attrmap

	def setup
		super
		@attributes = @options:attributes or []
		@attrmap = {}
		@classNames = []
		@className = null

	def isAbstract
		!isSlot and !isFragment

	def attrs
		@attributes

	def traverse
		return self if @traversed

		let close = @options:close
		let body = @options:body or []
		let returns = self

		if close and close.@value == '/>' and body.len
			returns = [self].concat(body.@nodes)
			@options:body = ArgList.new([])

		super

		return returns

	def visitBeforeBody stack
		let type = @options:type
		type && type.traverse

		if isSelf or (tagName.indexOf('-') >= 0) or isDynamicType or (type && type.isComponent)
			@options:custom = yes
			@kind = 'component'
		else
			@kind = 'element'

		if attrs:length == 0 && !@options:type
			@options:type = 'fragment'
			
		let tagName = self.tagName

		if tagName == 'slot'
			@kind = 'slot'

		elif tagName == 'fragment'
			@kind = 'fragment'
			
		if tagName == 'shadow-root'
			@kind = 'shadow-root'
			
		@tagName = tagName

		@dynamics = []

		@attributes = @attributes.filter do |item|

			if item isa TagFlag and item.isStatic
				@classNames.push(item.name.toRaw)
				return false

			if item == @attrmap:$key
				self.set(key: item.value)
				return false

			if !item.isStatic
				@dynamics.push(item)

			return true

		if @classNames:length
			@className = "'{@classNames.join(' ')}'"

		if isSlot
			# @tvar = tagvar('t'+oid)
			let name = @attrmap:name ? @attrmap:name.value : '__'
			name = name.raw if name isa Str
			set(name: name)
			@attributes = []
		super

	def register node
		node = super(node)

		if node isa TagLike and (isComponent and !isSelf)
			let slotKey = node isa Tag ? node.@attrmap:slot : null
			let name = '__'
			if slotKey
				if slotKey.value isa Str
					name = slotKey.value.raw
			# let name = slotKey ? slotKey.value .toRaw : '__'
			let slot = getSlot(name)
			node.@fragment = slot
		return node

	def visitAfterBody stack
		self

	def visitAfterConsumed
		if isSVG
			@kind = 'svg'		
		
		if @parent isa TagLoopFragment and isDynamicType
			if option(:key)
				set(key: OP('+',option(:key),OP('+',STR(' '),vvar)) )
		self

	def visitAfterConsumedChildren
		if isSlot and @consumed:length > 1
			set(markWhenBuilt: yes, reactive: yes)
		return

	def getSlot name
		@slots ||= {}
		@slots[name] ||= TagSlotProxy.new(parent: self, name: name)

	def addPart part, type, tok
		let attrs = @attributes
		let curr = attrs.CURRENT
		let next = curr

		if type == TagId
			set(id: part)

		if type == TagArgList
			if attrs:length == 0
				set(args: part)
				return self

		if type == TagSep
			next = null

		elif type == TagAttrValue
			if part isa Parens
				part = part.value

			if curr isa TagFlag
				curr.condition = part
				flag(F.TAG_HAS_DYNAMIC_FLAGS)
				curr.set(op: tok)

			elif curr
				curr.value = part
				curr.set(op: tok)

		elif curr isa TagHandler or curr isa TagAttr
			curr.add(part,type)

		elif type == TagData
			let bind = String(self.type) in ['input','textarea','select','button','option']
			curr = TagAttr.new(bind ? 'bind:model' : 'model')
			curr.value = part.first
			attrs.push(curr)
			next = null
		else
			if type == TagFlag and part isa IdentifierExpression and !part.isPrimitive
				flag(F.TAG_HAS_DYNAMIC_FLAGS)

			attrs.push(next = type.new(part,self))

			if next isa TagAttr and next.name.isPrimitive
				let name = String(next.name.toRaw)
				@attrmap[name] = next

		if next != curr
			attrs.CURRENT = next
		self

	def type
		@options:type || (@attributes:length == 0 ? :fragment : :div)

	def tagName
		@tagName || String(@options:type)

	def isDynamicType
		type isa ExpressionNode

	def isSVG
		@isSVG ?= ((type isa TagTypeIdentifier and type.isSVG) or (@parent and @parent.isSVG))
	
	def create_
		if isFragment or isSlot
			LIT('imba.createLiveFragment')
		elif isSVG
			LIT('imba.createSVGElement')
		elif isComponent
			LIT('imba.createComponent')
		else
			LIT('imba.createElement')

	def isReactive
		option(:reactive) or (@parent ? @parent.isReactive : !(scope__ isa RootScope))

	

	def isDetached
		option(:detached)

	def js o
		var isExpression = STACK.isExpression

		var head = []
		var out = []
		var foot = []

		var add = do |val|
			if val isa Variable
				val = val.toString
			out.push(val)

		var parent = self.parent
		var fragment = self.fragment

		let typ = isSelf ? "self" : (isFragment ? "'fragment'" : (type:isClass and type.isClass ? type.name : "'" + type.@value + "'"))

		var wasInline = o:inline
		var isSVG = self.isSVG
		var isReactive = self.isReactive

		var canInline = no
		var shouldEnd = isComponent or @attrmap:route or @attrmap:routeTo or @attrmap['route-to']

		var dynamicKey = null
		var ownCache = no

		var slotPath = isSlot ? OP('.',LIT("{fragment.root.tvar}.__slots"),STR(option(:name))).c : ""

		if STACK.tsc
			# if tag is expression we want to suppress certain warnings
			if type isa TagTypeIdentifier and !isSelf
				add "{tvar} = new {M(type.toClassName,type)}"
			else
				add "{tvar} = {type.c}"
			for item in @attributes
				if item isa TagAttr
					add item.c(o) # M("{tvar}.{item.c(o)}",item)
					# add M("{tvar}.{item.c(o)}",item)
				self
			for item in body
				add item.c

			return out.join(";\n")

		# whether this tag should set a variable indicating
		# whether this was built now or not
		# basically whether we need a reference at all?
		var markWhenBuilt = shouldEnd or hasDynamicFlags or attrs:length or option(:markWhenBuilt) or isDetached
		# when it has any attributes? - but not text or

		var inCondition = parent && parent.option(:condition)

		if type isa ExpressionNode
			add "{vvar}={type.c}"
			unless (option(:key) or parent isa TagLoopFragment)
				add "{kvar}='{oid}_'+{vvar}"

			typ = vvar
			dynamicKey = kvar

		var params = [
			typ,
			@flags,
			(fragment and !option(:detached) ? fragment.tvar : 'null'),
			@className or 'null',
			'null',
			stack.option(:hasScopedStyles) ? STR(stack.sfcid) : LIT('null')
		]

		var nodes = body ? body.values : []

		if nodes:length == 1 and nodes[0] isa TagContent and nodes[0].isStatic and !isSelf and !isSlot
			params[4] = nodes[0].value.c
			nodes = []

		# checking to see if a node is static enough to be inserted directly into the dom without
		# any references.
		if @dynamics:length == 0 and !hasDynamicFlags and !dynamicKey
			if nodes.every(|v| v isa Str or (v isa Tag and !v.isDynamicType))
				if !shouldEnd and !hasNonTagChildren and (parent isa Tag) and !isSlot and !option(:dynamic)
					canInline = yes

		if isFragment or isSlot
			params = params.slice(1,3)

		if isSlot
			# the slot is not supposed to be inserted immediately
			params[1] = 'null'

		var ctor = "{tvar}={M("{create_}({params.join(',')})",type)}"

		if option(:assign)
			# push it into ctor if it is not a variable assignment
			# otherwise we always want to assign it
			ctor = OP('=',option(:assign),LIT(ctor)).c()
		if option(:ivar)

			ctor = OP('=',OP('.',scope__.context,option(:ivar)),LIT(ctor)).c()

		if !parent
			@ref = "{tvar}"

			if isSelf
				add "{tvar}=this"
				add "{tvar}.open$()"
				
				#	add "{cvar} = ({bvar}={dvar}=1,{tvar}.$) || ({bvar}={dvar}=0,{tvar}.$=\{\},{tvar}S={tvar}.attachShadow(\{mode:'open'\}))"
				# else
				add "{cvar} = ({bvar}={dvar}=1,{tvar}.$) || ({bvar}={dvar}=0,{tvar}.$=\{\})"

			elif isReactive
				let scop = scope__.closure
				# add "{bvar}={dvar}=1"
				add "{tvar}=({bvar}={dvar}=1,{scop.tagCache}.{oid}) || ({bvar}={dvar}=0,{scop.tagCache}.{oid}={ctor})"
				add "{bvar}||({tvar}.up$={scop.tagCache}._)"
				@ref = tvar
				o:inline = yes if isExpression

				# TODO better determination re. if we need a cache or not
				if @consumed:length or @dynamics:length
					add "{cvar} = {tvar}.${oid} || ({tvar}.${oid}=\{\})"
			else
				@cvar = tvar
				add "({ctor})"
				option(:inline,canInline = yes)
				o:inline = yes

		else
			if isShadowRoot
				let key = "{cvar}.{oid}"
				add "{tvar}={key} || ({key}={fragment.tvar}.attachShadow(\{mode:'open'\}))"
					
			elif isSlot and !hasChildren
				let key = "{cvar}.{oid}"
				add("{tvar}={slotPath}")
				add("({key} = {fragment.tvar}.insert$({tvar},{@flags},{key}))")
			elif isSlot and @consumed:length == 1
				# single child can act as slot?
				# if it is a string we dont really want to insert it at all
				@consumed[0].set(dynamic: yes, detached: yes)
				@consumed[0].@tvar = tvar
				# add("{tvar}")
			# this is a functional tag component
			elif option(:args)
				let key = "{cvar}.{oid}"
				add("imba.ctx=({key}$c || ({key}$c=\{\}))")
				let call = CALL(option(:type).toFunctionalType,option(:args))
				add("{tvar}={call.c(o)}")
				add("{tvar}==={ref} || ({key}_ = {fragment.tvar}.insert$({ref}={tvar},{@flags},{key}_))")
				# call the tag - type?

			elif parent isa TagLoopFragment
				# what if we are not reactive at all?
				if parent.isKeyed and !option(:key)
					option(:key,OP('+',LIT("'{oid}$'"),parent.kvar))
					if isDynamicType
						set(key: OP('+',option(:key),vvar))
					# @ref = "{parent.cvar}[{parent.kvar}]"

				if option(:key)
					add "{kvar}={option(:key).c}"
					@ref = "{parent.cvar}[{kvar}]"
				elif parent.isIndexed
					@ref = "{parent.cvar}[{parent.kvar}]"

				# if we add our own bvar?
				@bvar = tagvar(:b)
				add "{tvar} = ({bvar}={dvar}=1,{ref}) || ({bvar}={dvar}=0,{ref} = {ctor})"
				@ref = "{tvar}"

				if isDetached or true
					add "{bvar}||({tvar}.up$={fragment.tvar})"

				# dont add cvar always!
				# rule is just "do we need our own cache?"
				if @dynamics:length or (@consumed:length and nodes:length)
					ownCache = yes
					# console.log "has dynamics? {@dynamics:length}",@consumed.map(|v| v:constructor:name)
					# @cvar = tagvar(:c)
					# add "{cvar}={ref}.${oid} || ({ref}.${oid}=\{\})"

			elif !isReactive
				add "({ctor})"

			elif canInline
				@ref = tvar
				@bvar = parent.bvar
				add "{parent.bvar} || ({ctor})"
			else
				let cref = @cref = "{cvar}.{oid}"
				let ref = dynamicKey ? "{cvar}[{dynamicKey}]" : cref

				if markWhenBuilt
					@bvar = tagvar(:b)
					add "{tvar} = ({bvar}={dvar}=1,{ref}) || ({bvar}={dvar}=0,{ref}={ctor})"
				else
					add "{tvar} = {ref} || ({ref} = {ctor})"

				if isDetached
					add "{bvar}||({tvar}.up$={fragment.tvar})"

				@ref = tvar

				if dynamicKey # and cache
					ownCache = yes

			if ownCache
				@cvar = tagvar(:c)
				add "{cvar}={ref}.${oid} || ({ref}.${oid}=\{\})"


					

		if @slots
			for own name, slot of @slots
				# TODO Make sure slot is not already used
				add "{slot.tvar} = {tvar}.slot$('{name}',{cvar})"

		let flagsToConcat = []

		for item in @attributes
			if item.@chain and item.@chain:length and !(item isa TagHandler)
				let mods = item.modifiers
				let dyn = !mods.isStatic

				let specials = mods.extractDynamics()
				let modid = item.modsIdentifier
				let modpath = modid ? OP('.',tvar,modid).c : "{cvar}.{mods.oid}"

				if dyn
					add "{vvar} = {modpath} || ({mods.c(o)})"
					for special in specials
						let k = special.option(:key)
						let i = special.option(:index)
						add "{OP('.',vvar,k).c}[{i}]={special.c(o)}"
					add "{bvar} || ({modpath}={vvar})"
				else
					add "{bvar} || ({modpath}={mods.c(o)})"

			if !isReactive
				# buggy
				add "{tvar}.{item.c(o)}"
			elif item.isStatic
				add "{bvar} || ({tvar}.{item.c(o)})"
			else
				let iref = "{cvar}.{item.oid}"

				if item isa TagFlag
					let cond = item.condition
					let val = item.name
					let cref
					let vref

					if cond and !cond.isPrimitive
						cref = "{cvar}.{cond.oid}"
						add "({vvar}=({cond.c(o)}||undefined),{vvar}==={cref}||({dvar}|={F.DIFF_FLAGS},{cref}={vvar}))"

					if val and !(val isa Token) and !val.isPrimitive
						vref = "{cvar}.{val.oid}"
						add "({vvar}={val.c(o)},{vvar}==={vref}||({dvar}|={F.DIFF_FLAGS},{vref}={vvar}))"

					if cref and vref
						flagsToConcat.push("({cref} ? ({vref}||'') : '')")
					elif cref
						flagsToConcat.push("({cref} ? {val.c(as:'string')} : '')")
					elif vref
						flagsToConcat.push("({vref}||'')")
					else
						flagsToConcat.push("'{val.c}'")

				elif item isa TagHandler
					let mods = item.modifiers
					let specials = mods.extractDynamics()
	
					add "{vvar} = {iref} || ({iref}={mods.c(o)})"
					for special in specials
						let k = special.option(:key)
						let i = special.option(:index)
						add "{OP('.',vvar,k).c}[{i}]={special.c(o)}"

					mods = vvar
					add "{bvar} || {ref}.on$({item.quoted},{mods.c},{scope__.context.c})"

				elif item isa TagAttr and item.ns == 'bind'
					
					let rawVal = item.value
					let val = PATHIFY(rawVal)

					shouldEnd = yes
					if val isa Array
						let target = val[0]
						let key = val[1]
						let bval = "[]"
						if target isa Literal and key isa Literal
							bval = "[{target.c(o)},{key.c(o)}]"
						elif key isa Literal
							bval = "[null,{key.c(o)}]"

						add "{vvar}={iref} || ({iref}={ref}.bind$('{item.key}',{bval}))"
						for part,i in val
							unless part isa Literal
								add "{vvar}[{i}]={part.c(o)}"
						# add "({vvar}={rawVal.c(o)},{vvar}=={ref}.value || ({iref}={ref}.bind$('{item.key}',{mods},{bval}))"
					elif val isa Variable
						let getter = "function()\{ return {val.c(o)} \}"
						let setter = "function(v$)\{ {val.c(o)} = v$ \}"
						let bval = "\{get:{getter},set:{setter}\}"
						add "{bvar} || {ref}.bind$('{item.key}',{bval})"
				else
					item.option(svg: true) if isSVG
					let val = item.value
					if item.valueIsStatic
						add "{bvar} || ({ref}.{M(item.js(o),item)})"
					elif val isa Func
						add "({ref}.{item.js(o)})"
					else
						item.value = LIT("{iref}={vvar}")
						add "({vvar}={val.c(o)},{vvar}==={iref} || ({ref}.{M item.js(o),item}))"

		if flagsToConcat:length or (isSelf && @className)
			flagsToConcat.unshift(@className) if @className
			let meth = isSelf ? 'flagSelf$' : 'flag$'
			let cond = "{dvar}&{F.DIFF_FLAGS}"
			cond = "(!{bvar}||{cond})" if isSelf
			add "({cond} && {tvar}.{meth}({flagsToConcat.join("+' '+")}))"

		# When there is only one value and that value is a static string or num - include it in ctor
		# loop through attributes etc
		# add 

		let count = nodes:length

		for item in nodes
			if item isa Str # static for sure
				# should this not go into a TagLike? Definitely
				if isReactive
					add "{bvar} || {tvar}.insert$({item.c(o)})"
				else
					add "{tvar}.insert$({item.c(o)})"
			else
				add item.c(o)


		if shouldEnd
			foot.push("{bvar} || !{tvar}.setup || {tvar}.setup({dvar})") unless isSelf
			foot.push(isSelf ? "{tvar}.close$({dvar})" : "{tvar}.end$({dvar})")

		if parent isa TagLoopFragment
			
			if parent.isKeyed
				foot.push "{parent.ref}.push({tvar},{parent.kvar}++,{kvar})"
			elif parent.isIndexed
				foot.push "{parent.kvar}++"

		elif isFragment and parent and !(parent isa TagSwitchFragment)
			# not fragment.tvar?
			foot.push "{fragment.ref}.insert$({tvar},{@flags})"

		elif parent and isComponent and !(parent isa TagSwitchFragment)
			let pref = fragment.ref
			let cref = @cref
			if dynamicKey
				foot.push "({tvar}=={cref}) || (!{cref} && ({cref}={tvar}).insertInto$({pref})) || {cref}.replaceWith$({cref}={tvar})"
			else
				foot.push "{bvar} || {tvar}.insertInto$({pref})"

		if option(:fragmented)
			add "imba.ctx=null"

		if !parent
			if option(:return)
				foot.push "return {tvar}"
			elif !isReactive or o:inline
				foot.push "{tvar}"

		out = out.concat(foot)

		if o:inline
			o:inline = wasInline
			let js = '(' + out.join(',\n') + ')'
			if isSlot and hasChildren
				let key = "{cvar}.{oid}"
				let post = "{tvar}==={key}__ || ({key}_ = {fragment.tvar}.insert$({key}__={tvar},{@flags},{key}_))"
				js = "({tvar}={slotPath}),(!{tvar} || {tvar}.isEmpty$() && {js}),({post})"
			return js
		else
			o:inline = wasInline
			let js = out.join(";\n")
			if isSlot and hasChildren
				let key = "{cvar}.{oid}"
				let post = "{tvar}==={key}__ || ({key}_ = {fragment.tvar}.insert$({key}__={tvar},{@flags},{key}_))"
				js = "{tvar}={slotPath};\nif(!{tvar} || {tvar}.isEmpty$())\{\n{js}\n\}\n{post}"
			return js


export class TagWrapper < ValueNode

	def visit
		if value isa Array
			value.map(|v| v.traverse)
		else
			value.traverse
		self

	def c
		"{scope__.imba.c}.getTagForDom({value.c(expression: yes)})"


# SELECTORS


export class Selector < ListNode

	def initialize list, options
		@nodes = list or []
		@options = options

	def add part, typ
		push(part)
		self

	def isExpressable
		yes

	def visit
		for item in @nodes
			item.traverse unless item isa Token

	def query
		var str = ""
		var ary = []

		for item in nodes
			var val = item.c
			if item isa Token
				ary.push("'" + val.replace(/\'/g,'"') + "'")
			else
				ary.push(val)

		return ary.join(' + ')


	def js o
		var typ = option(:type)
		var q = AST.c(query)
		var imba = scope__.imba.c

		if typ == '%'
			"{imba}.q$({q},{o.scope.context.c(explicit: yes)})" # explicit context
		elif typ == '%%'
			"{imba}.q$$({q},{o.scope.context.c(explicit: yes)})"
		else
			"{imba}.q{typ}({q})"

export class SelectorPart < ValueNode

# DEFER

export class Await < ValueNode

	prop func

	def js o
		return "await {value.c}" if option(:native)
		# introduce a util here, no?
		CALL(OP('.',Util.Promisify.new([value]),'then'),[func]).c

	def visit o
		# things are now traversed in a somewhat chaotic order. Need to tighten
		# Create await function - push this value up to block, take the outer
		value.traverse

		var fnscope = o.up(Func) # do |item| item isa MethodDeclaration or item isa Fun

		if !o.es5
			if fnscope
				set(native: yes)
				fnscope.set(async: yes)
				return self
			else
				# add warning
				# should add as diagnostics - no?
				warn "toplevel await not allowed"

		var block = o.up(Block) # or up to the closest FUNCTION?
		var outer = o.relative(block,1)
		var par = o.relative(self,-1)

		func = AsyncFunc.new([],[])
		# now we move this node up to the block
		func.body.nodes = block.defers(outer,self)
		func.scope.visit

		# if the outer is a var-assignment, we can simply set the params
		if par isa Assign
			par.left.traverse
			var lft = par.left.node
			# Can be a tuple as well, no?
			if lft isa VarReference
				# the param is already registered?
				# should not force the name already??
				# beware of bugs
				func.params.at(0,yes,lft.variable.name)
			else
				par.right = func.params.at(0,yes)
				func.body.unshift(par)
				func.scope.context

		# If it is an advance tuple or something, it should be possible to
		# feed in the paramlist, and let the tuple handle it as if it was any
		# other value

		# CASE If this is a tuple / multiset with more than one async value
		# we need to think differently.

		# now we need to visit the function as well
		func.traverse
		# pull the outer in
		self

export class AsyncFunc < Func

	def initialize params, body, name, target, options
		super(params,body,name,target,options)

	def scopetype do LambdaScope


# IMPORTS
export class ESMSpecifier < Node
	prop alias
	prop name

	def initialize name, alias
		@name = name
		@alias = alias

	def visit
		@declaration = STACK.up(ESMDeclaration)
		if @declaration isa ImportDeclaration
			@importer = @declaration
		else
			@exporter = @declaration
		@cname = helpers.clearLocationMarkers(@name.c())
		@key = @alias ? helpers.clearLocationMarkers(@alias.c()) : @cname
		
		# only register variable for imports?
		
		if @exporter
			# lookup variable
			unless @exporter.source
				@variable = scope__.root.lookup(@cname)
		else
			@variable = scope__.root.register(@key, self, type: 'const')
		self


	def js
		if @alias
			"{@name.c()} as {@alias.c()}"
		else
			"{@name.c()}"


export class ImportSpecifier < ESMSpecifier

	def visit
		super
		if @importer and STACK.cjs
			# FIXME will bug out if trying to set the variable
			@variable.@c = OP('.',@importer.variable,@name).c

export class ImportNamespaceSpecifier < ESMSpecifier

	def visit
		super
		if @importer and STACK.cjs
			# FIXME will bug out if trying to set the variable
			@variable.@c = @importer.variable.c
		
		
export class ExportSpecifier < ESMSpecifier

export class ExportAllSpecifier < ESMSpecifier

export class ImportDefaultSpecifier < ESMSpecifier

	def visit
		super
		if STACK.cjs
			if @importer
				@variable.@c = "{@importer.variable.c}.default"

export class ESMSpecifierList < ListNode
	
	def js
		'{' + super + '}'


export class ESMDeclaration < Statement
	prop variable
	prop source
	
	def initialize keyword, specifiers, source
		setup
		@keyword = keyword
		@specifiers = specifiers
		@source = source
		@defaults = (specifiers and specifiers.find(do $1 isa ImportDefaultSpecifier))

	def isExport
		String(keyword) == 'export'

	def js
		let kw = M(keyword.c,keyword)
		if @specifiers and @source
			"{kw} {AST.cary(@specifiers).join(',')} from {@source.c}"
		elif @specifiers
			"{kw} {AST.cary(@specifiers).join(',')}"
		elif @source
			"{kw} {@source.c}"

export class ImportDeclaration < ESMDeclaration

	def js
		if STACK.cjs
			var src = @source.c
			# we need to combine the requires
			let reqjs = "require({src})"
			unless @specifiers
				return reqjs
			
			# let wildcards = 
			if @defaults and @specifiers:length == 1
				return "var {@variable.c} = {util.requireDefault(LIT(reqjs)).c}"
			else
				return "var {@variable.c} = {reqjs}"

		if @specifiers and @source
			"{M(keyword.c,keyword)} {AST.cary(@specifiers).join(',')} from {@source.c}"
		else
			"{M(keyword.c,keyword)} {@source.c}"

	def visit
		if STACK.cjs and @specifiers
			var src = @source.c
			var m = helpers.clearLocationMarkers(src).match(/([\w\_\-]+)(\.js|imba)?[\"\']$/)
			@alias = m ? '_$' + m[1].replace(/[\/\-]/g,'_') : 'mod$'
			@variable = scope__.register(@alias,null,system: yes)
		
		for item in @specifiers
			item?.traverse()
			
		return

export class ExportDeclaration < ESMDeclaration

	def visit
		scope__.root.activateExports()

		for item in @specifiers
			item?.traverse()
		self
		
	def js
		let kw = M(keyword.c,keyword)
		let cjs = STACK.cjs
		
		if cjs
			let out = []
			
			if @source
				@variable ||= scope__.register(null,null,system: yes)
				let decl = "var {@variable.c} = require({@source.c})"
				out.push(decl)
				
				let tpl = '''
				Object.defineProperty(exports, $name$, {
					enumerable: true, get: function get() { return $path$; }
				});
				'''
				
				for item in @specifiers[0]
					let js = tpl.replace('$name$',(item.alias or item.name).toStr().c())
					js = js.replace('$path$',OP('.',@variable,item.name).c())
					out.push(js)

			else
				for item in @specifiers[0]
					let op = OP('=',OP('.',LIT('exports'),item.alias or item.name),item.@variable)
					out.push(op.c)

			return out.join(';\n')

		if @specifiers and @source
			"{kw} {AST.cary(@specifiers).join(',')} from {@source.c}"
		elif @specifiers
			"{kw} {AST.cary(@specifiers).join(',')}"
		elif @source
			"{kw} {@source.c}"
		

export class ExportAllDeclaration < ExportDeclaration
export class ExportNamedDeclaration < ExportDeclaration

export class Export < ValueNode
		
	def loc
		let kw = option(:keyword)
		kw and kw:region ? kw.region : super

	def consume node
		if node isa Return
			option('return',yes)
			return self
		super
		
	def visit
		scope__.root.activateExports()

		value.set(
			export: (option(:keyword) or self),
			return: option(:return),
			default: option(:default)
		)
		super

	def js o
		# p "Export {value}"
		# value.set export: self, return: option(:return), default: option(:default)

		# if value isa VarOrAccess
		# 	return "exports.{value.c} = {value.c};"

		if value isa ListNode
			value.map do |item| item.set export: self

		return value.c

export class Require < ValueNode

	def js o
		var out = value isa Parens ? value.value.c : value.c
		out == 'require' ? 'require' : "require({out})"

export class EnvFlag < ValueNode

	def raw
		@raw ?= STACK.env("" + @value)

	def isTruthy
		var val = raw
		return !!val if val !== undefined
		return undefined

	def loc
		[0,0]

	def c
		var val = raw
		if val !== undefined
			if val isa String
				if val.match(/^\d+(\.\d+)?$/)
					parseFloat(val)
				else
					"'{val}'"
			else
				"{val}"

		else
			"ENV_{@value}"


# UTILS

export class Util < Node

	prop args

	def initialize args
		@args = args

	# this is how we deal with it now
	def self.extend a,b
		Util.Extend.new([a,b])

	def self.callImba scope, meth, args
		CALL(OP('.',scope.imba,Identifier.new(meth)),args)

	def self.repeat str, times
		var res = ''
		while times > 0
			if times % 2 == 1
				res += str
			str += str
			times >>= 1
		return res


	def self.keys obj
		var l = Const.new("Object")
		var r = Identifier.new("keys")
		CALL(OP('.',l,r),[obj])

	def self.len obj, cache
		var r = Identifier.new("length")
		var node = OP('.', obj, r)
		node.cache(force: yes, pool: 'len') if cache
		return node

	def self.indexOf lft, rgt
		var node = Util.IndexOf.new([lft,rgt])
		# node.cache(force: yes, type: 'iter') if cache
		return node

	def self.slice obj, a, b
		var slice = Identifier.new("slice")
		console.log "slice {a} {b}"
		return CALL(OP('.',obj,slice),AST.compact([a,b]))

	def self.iterable obj, cache
		return obj if STACK.tsc
		var node = Util.Iterable.new([obj])
		node.cache(force: yes, pool: 'iter') if cache
		return node

	def self.counter start, cache
		# should it not rather be a variable?!?
		var node = Num.new(start) # make sure it really is a number
		node.cache(force: yes, pool: 'counter') if cache
		return node

	def self.array size, cache
		var node = Util.Array.new([size])
		node.cache(force: yes, pool: 'list') if cache
		return node

	def inlineHelpers
		!!OPTS:inlineHelpers

	def name
		'requireDefault$'

	def js
		scope__.root.helper(self,helper)
		"{name}({@args.map(|v| v.c).join(',')})"


var HELPERS = {
	setField: '''(target,key,value,o){
		Object.defineProperty(target,key,{value:value});
	};'''

	extendTag: '''(el,cls){
		Object.defineProperties(el,Object.getOwnPropertyDescriptors(cls.prototype));
		return el;
	};'''

	initField: '''(target,key,o){
		Object.defineProperty(target,key,o);
	};'''

	decorate: '''(decorators,target,key,desc){
		var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
		if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
		else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
		return c > 3 && r && Object.defineProperty(target, key, r), r;
	};'''
	
	requireDefault: '''(obj){
		return obj && obj.__esModule ? obj : { default: obj };
	};'''
}

export class Util.Helper < Util
	def name
		option(:name)

	def helper
		option(:helper)

for own k,v of HELPERS
	Util[k] = do |*args|
		let helper = 'function ' + k + '$' + v
		Util.Helper.new(args).set(name: k + '$', helper: helper)


export class Util.Extend < Util
	def helper
		'''
		function extend$(target,ext){
			var descriptors = Object.getOwnPropertyDescriptors(ext);
			Object.defineProperties(target.prototype,descriptors);
			return target;
		};
		'''

	def js o
		# When this is triggered, we need to add it to the top of file?
		scope__.root.helper(self,helper)
		"extend$({AST.compact(AST.cary(args)).join(',')})"

export class Util.IndexOf < Util

	def helper
		'''
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		'''

	def js o
		if inlineHelpers
			scope__.root.helper(self,helper)
			# When this is triggered, we need to add it to the top of file?
			"idx$({args.map(|v| v.c ).join(',')})"
		else
			"{scope__.imba.c}.indexOf({args.map(|v| v.c ).join(',')})"

export class Util.Len < Util

	def helper
		'''
		function len$(a){
			return a && (a.len instanceof Function ? a.len() : a.length) || 0;
		};
		'''

	def js o
		# 
		if true # isStandalone
			scope__.root.helper(self,helper)
			# When this is triggered, we need to add it to the top of file?
			"len$({args.map(|v| v.c ).join(',')})"
		else
			"{scope__.imba.c}.len({args.map(|v| v.c ).join(',')})"


export class Util.Promisify < Util

	def helper
		# should also check if it is a real promise
		'''
		function promise$(a){
			if(a instanceof Array){
				console.warn("await (Array) is deprecated - use await Promise.all(Array)");
				return Promise.all(a);
			} else {
				return (a && a.then ? a : Promise.resolve(a));
			}
		}
		'''

	def js o
		if inlineHelpers
			# When this is triggered, we need to add it to the top of file?
			scope__.root.helper(self,helper)
			"promise$({args.map(|v| v.c).join(',')})"
		else
			"{scope__.imba.c}.await({args.map(|v| v.c).join(',')})"

export class Util.Iterable < Util

	def helper
		# now we want to allow null values as well - just return as empty collection
		# should be the same for for own of I guess
		"function iter$(a)\{ return a ? (a.toIterable ? a.toIterable() : a) : []; \};"

	def js o
		return args[0].c if args[0] isa Arr # or if we know for sure that it is an array

		scope__.root.helper(self,helper)
		return "iter$({args[0].c})"

export class Util.RequireDefault < Util
	
	def helper
		# now we want to allow null values as well - just return as empty collection
		# should be the same for for own of I guess
		'''function requireDefault$(obj){
			return obj && obj.__esModule ? obj : { default: obj };
		};'''

	# function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

export class Util.IsFunction < Util

	def js o
		"{args[0].c}"

export class Util.Array < Util

	def js o
		# When this is triggered, we need to add it to the top of file?
		"new Array({args.map(|v| v.c)})"




class Entities

	def initialize root
		@root = root
		@map = []
		return self

	def add path, object
		@map[path] = object
		unless @map.indexOf(object) >= 0
			@map.push(object)
		self

	def lookup path
		@map[path]

	# def register entity
	# 	var path = entity.namepath
	# 	@map[path] ||= entity
	# 	self

	def plain
		JSON.parse(JSON.stringify(@map))

	def toJSON
		@map

class RootEntities
	
	def initialize root
		@root = root
		@map = {}
		return self

	def add path, object
		@map[path] = object
		self

	def register entity
		var path = entity.namepath
		@map[path] ||= entity
		self

	def plain
		JSON.parse(JSON.stringify(@map))

	def toJSON
		@map
	
# SCOPES

# handles local variables, self etc. Should create references to outer scopes
# when needed etc.

# add class for annotations / registering methods, etc?
# class Interface

# should move the whole context-thingie right into scope
export class Scope

	prop level
	prop context
	prop node
	prop parent
	prop varmap
	prop varpool
	prop params
	prop head
	prop vars
	prop counter
	prop entities

	def p
		if STACK.loglevel > 0
			console.log(*arguments)
		self
	
	def oid
		@oid ||= STACK.generateId('')

	def stack
		STACK

	def initialize node, parent
		@nr = STACK.incr('scopes')
		@head = []
		@node = node
		@parent = parent
		@vars = ScopeVariables.new([])
		@entities = Entities.new(self)
		@meta = {}
		@annotations = []
		@closure = self
		@virtual = no
		@counter = 0
		@varmap  = {}
		@counters = {}
		@varpool = []
		@refcounter = 0
		@level = (parent ? parent.@level : -1) + 1
		setup
		
	def setup
		@selfless = yes
		
	def incr name = 'i'
		var val = @counters[name] ||= 0
		@counters[name]++
		return val

	def nextShortRef
		AST.counterToShortRef(@refcounter++)

	def meta key, value
		if value != undefined
			@meta[key] = value
			return self
		@meta[key]

	def namepath
		'?'
		
	def tagCache
		# deal with root instead?
		@tagCache ||= declare('c$$',
			# LIT('(Imba.$c ? (Imba.$c[Imba.$k] || (Imba.$c[Imba.$k] = {})) : {})'),
			LIT('(imba.ctx||{})'),
			system: yes
		)
	# def context
	# 	@context ||= ScopeContext.new(self)
		
	def context
		# why do we need to make sure it is referenced?
		unless @context
			if selfless
				@context = parent.context.fromScope(self)
				# @context.reference(self)
			else
				@context = ScopeContext.new(self)
		return @context

	def traverse
		self

	def visit
		return self if @parent
		@parent = STACK.scope(1) # the parent scope
		@level = STACK.scopes:length - 1

		STACK.addScope(self)
		root.scopes.push(self)
		self

	def wrap scope
		@parent = scope.@parent
		scope.@parent = self
		self

	# called for scopes that are not real scopes in js
	# must ensure that the local variables inside of the scopes do not
	# collide with variables in outer scopes -- rename if needed
	def virtualize
		self

	def root
		return STACK.ROOT

		var scope = self
		while scope
			return scope if scope isa RootScope
			scope = scope.parent
		return null

	def register name, decl = null, o = {}
		# FIXME re-registering a variable should really return the existing one
		# Again, here we should not really have to deal with system-generated vars
		# But again, it is important

		if !name
			o:system = yes

		if o:system
			return SystemVariable.new(self,name,decl,o)

		name = helpers.symbolize(name)

		# also look at outer scopes if this is not closed?
		var existing = @varmap.hasOwnProperty(name) && @varmap[name]
		
		if existing
			if decl
				decl.warn('Cannot redeclare variable')
			console.log 'redeclaring variable',"{existing} {decl}"
			
		# FIXME check if existing is required to be unique as well?
		if existing and !o:unique
			return existing

		# var type = o:system ? SystemVariable : Variable
		var item = Variable.new(self,name,decl,o)
		
		if !o:system and !existing
			@varmap[name] = item

		if STACK.state and STACK.state:variables isa Array
			STACK.state:variables.push(item)
		return item

	def annotate obj
		@annotations.push(obj)
		self

	# just like register, but we automatically
	def declare name, init = null, o = {}
		var variable = name isa Variable ? name : register(name,null,o)
		# TODO create the variabledeclaration here instead?
		# if this is a sysvar we need it to be renameable
		var dec = @vars.add(variable,init)
		variable.declarator ||= dec
		return variable

	
	def reusevar name
		temporary(null,{reuse: yes},name)

	# what are the differences here? omj
	# we only need a temporary thing with defaults -- that is all
	# change these values, no?
	def temporary decl, o = {}, name = null
		if name and o:reuse and @vars["_temp_{name}"]
			return @vars["_temp_{name}"]

		if o:pool
			for v in @varpool
				if v.pool == o:pool && v.declarator == null
					return v.reuse(decl)

		var item = SystemVariable.new(self,name,decl,o)
		
		@varpool.push(item) # It should not be in the pool unless explicitly put there?
		@vars.push(item) # WARN variables should not go directly into a declaration-list
		if name and o:reuse
			@vars["_temp_{name}"] = item
		return item

	def lookup name
		@lookups ||= {}
		var ret = null
		name = helpers.symbolize(name)
		if @varmap.hasOwnProperty(name)
			ret = @varmap[name]
		else
			ret = parent && parent.lookup(name)

			if ret
				@nonlocals ||= {}
				@nonlocals[name] = ret
		ret

	def requires path, name = ''
		root.requires(path,name)

	def imba
		root.imba # requires('imba2', 'Imba')

	def imbaTags
		root.imbaTags
		
	def imbaRef name, shorthand = '_'
		root.imbaRef(name,shorthand)

	def imbaDependency *params
		root.imbaDependency(*params)

	def autodeclare variable
		vars.push(variable) # only if it does not exist here!!!

	def free variable
		variable.free # :owner = null
		# @varpool.push(variable)
		self

	def selfless
		!!@selfless

	def closure
		@closure

	def finalize
		self

	def klass
		var scope = self
		while scope
			scope = scope.parent
			return scope if scope isa ClassScope
		return null

	def head
		[@vars,@params]

	def c o = {}
		o:expression = no
		# need to fix this
		node.body.head = head
		var body = node.body.c(o)

	def region
		node.body.region

	def loc
		node.loc

	def dump
		var vars = Object.keys(@varmap).map do |k|
			var v = @varmap[k]
			# unless v.@declarator isa Scope
			# 	console.log v.name, v.@declarator:constructor:name
			# AST.dump(v)
			v.references:length ? AST.dump(v) : null

		var desc =
			nr: @nr
			type: self:constructor:name
			level: (level or 0)
			vars: AST.compact(vars)
			loc: loc

		return desc

	def toJSON
		dump

	def toString
		"{self:constructor:name}"

	def closeScope
		self


# RootScope is wrong? Rather TopScope or ProgramScope
export class RootScope < Scope

	prop warnings
	prop scopes
	prop entities
	prop object
	prop styles
	prop options

	def initialize
		super

		register 'global', self, type: 'global'
		register 'imba', self, type: 'global'
		register 'module', self, type: 'global'
		register 'window', self, type: 'global'
		register 'document', self, type: 'global'
		register 'exports', self, type: 'global'
		register 'console', self, type: 'global'
		register 'process', self, type: 'global'
		register 'parseInt', self, type: 'global'
		register 'parseFloat', self, type: 'global'
		register 'setTimeout', self, type: 'global'
		register 'setInterval', self, type: 'global'
		register 'setImmediate', self, type: 'global'
		register 'clearTimeout', self, type: 'global'
		register 'clearInterval', self, type: 'global'
		register 'clearImmediate', self, type: 'global'
		register 'isNaN', self, type: 'global'
		register 'isFinite', self, type: 'global'
		register '__dirname', self, type: 'global'
		register '__filename', self, type: 'global'
		register '_', self, type: 'global'

		# preregister global special variables here
		@requires = {}
		@warnings = []
		@scopes   = []
		@helpers  = []
		@styles = []
		@selfless = no
		@implicitAccessors = []
		@entities = RootEntities.new(self)
		@object = Obj.wrap({})
		@head = [@vars]
		@dependencies = {}
		self

	def sfcid
		@sfcid ||= @options:sourcePath and helpers.identifierForPath(@options:sourcePath)
	# single-file-component options
	def sfco
		@sfco ||= declare('sfc$',LIT('{/*$sfc$*/}'))

	def context
		@context ||= RootScopeContext.new(self)

	def globalRef
		let js = "(typeof window !== 'undefined' ? window : (typeof global !== 'undefined' ? global : null))"
		@globalRef ||= declare('global$',LIT(js))
		
	def activateExports
		if STACK.cjs and !@hasExports
			@hasExports = yes
			@head.push(LIT('Object.defineProperty(exports, "__esModule", {value: true});'))

	def lookup name
		name = helpers.symbolize(name)
		@varmap[name] if @varmap.hasOwnProperty(name)

	def visit
		STACK.addScope(self)
		self

	def helper typ, value
		# log "add helper",typ,value
		if @helpers.indexOf(value) == -1
			@helpers.push(value)
			@head.unshift(value)

		return self

	def head
		@head

	def warn data
		# hacky
		data:node = null
		@warnings.push(data)
		self

	def dump
		var obj = {
			warnings: AST.dump(@warnings)
			autoself: @implicitAccessors.map(|s| s.dump)
		}

		if OPTS:analysis:scopes
			var scopes = @scopes.map(|s| s.dump)
			scopes.unshift(super.dump)
			obj:scopes = scopes

		if OPTS:analysis:entities
			obj:entities = @entities

		return obj

	

	# not yet used
	def requires path, name
		if var variable = lookup(name)
			return variable

		if var variable = @requires[name]
			if variable.@requirePath != path
				throw Error.new("{name} is already defined as require('{variable.@requirePath}')")
			return variable

		var req = Require.new(Str.new("'" + path + "'"))
		var variable = Variable.new(self,name,null,system: yes)
		var dec = @vars.add(variable, req)
		variable.declarator ||= dec
		variable.@requirePath = path
		@requires[name] = variable
		return variable

	def imba
		LIT('imba')
		# root.requires('imba2', 'Imba')

	def imbaTags
		return @imbaTags if @imbaTags
		var imbaRef = self.imba
		# don't add if we cannot be certain that imba is required on top
		if @requires.Imba
			@imbaTags = declare('_T',OP('.',imbaRef,'TAGS'))
		else
			@imbaTags = "{imbaRef.c}.TAGS"

	def imbaDependency path
		return if OPTS:imbaPath === null or OPTS:standalone or OPTS:target == 'tsc'
		@dependencies[path] ||= if true
			let item = LIT("import '{OPTS:imbaPath or 'imba'}/src/imba/{path}'")
			@head.push(item)
			item
			
	def imbaRef name, shorthand = '_'
		if name == 'tagscope'
			name = 'createTagScope(/*SCOPEID*/)'
		elif name == 'tagfactory'
			name = 'createElementFactory(/*SCOPEID*/)'

		var map = @imbaRefs ||= {}
		return map[name] if map[name]

		var imbaRef = self.imba
		
		if @requires.Imba
			map[name] = declare(shorthand,OP('.',imba,name), system: yes)
		else
			map[name] = "{imbaRef.c}.{name}"
		

	def c o = {}
		o:expression = no
		# need to fix this
		node.body.head = head
		var body = node.body.c(o)

		return body

export class ModuleScope < Scope

	def setup
		@selfless = no

	def namepath
		@node.namepath

export class ClassScope < Scope
	
	def setup
		@selfless = no

	def namepath
		@node.namepath

	# called for scopes that are not real scopes in js
	# must ensure that the local variables inside of the scopes do not
	# collide with variables in outer scopes -- rename if needed
	def virtualize
		# console.log "virtualizing ClassScope"
		var up = parent
		for own k,v of @varmap
			v.resolve(up,yes) # force new resolve
		self
		
	def prototype
		@prototype ||= ValueNode.new(OP('.',context,'prototype'))

export class TagScope < ClassScope

export class ClosureScope < Scope

export class FunctionScope < Scope

export class MethodScope < Scope

	def setup
		@selfless = no

export class LambdaScope < Scope

	def context
		# why do we need to make sure it is referenced?
		unless @context
			@context = parent.context.fromScope(self)
		@context


export class FlowScope < Scope

	# these have no params themselves, refer to outer scopes -- hjmm
	def params
		@parent.params if @parent

	def register name, decl = null, o = {}
		if o:type != 'let' and (closure != self)
			if var found = lookup(name)
				if found.type == 'let'
					# p "{name} already exists as a block-variable {decl}"
					# TODO should throw error instead
					decl.warn "Variable already exists in block" if decl
					# root.warn message: "Holy shit"
			closure.register(name,decl,o)
		else
			super(name,decl,o)

	# FIXME should override temporary as well

	def autodeclare variable
		parent.autodeclare(variable)

	def closure
		@parent.closure # this is important?

	def context
		@context ||= parent.context

	def closeScope
		# FIXME
		@context.reference if @context
		self

export class CatchScope < FlowScope

export class WhileScope < FlowScope

	def autodeclare variable
		vars.push(variable)

export class ForScope < FlowScope

	def autodeclare variable
		vars.push(variable)

	def temporary refnode, o = {}, name = null
		parent.temporary(refnode,o,name)

export class IfScope < FlowScope

	def temporary refnode, o = {}, name = null
		parent.temporary(refnode,o,name)
		
	

export class BlockScope < FlowScope

	def temporary refnode, o = {}, name = null
		parent.temporary(refnode,o,name)

	def region
		node.region

# lives in scope -- really a node???
export class Variable < Node

	prop scope
	prop name
	prop alias
	prop type
	prop options
	prop initialized
	prop declared
	prop declarator
	prop autodeclare
	prop references
	prop export

	def pool
		null

	def initialize scope, name, decl, o
		@ref = STACK.@counter++
		@c = null
		@scope = scope
		@name  = name
		@alias = null
		@initialized    = yes
		@declarator  	= decl
		@autodeclare 	= no
		@declared		= o and o:declared || no
		@resolved		= no
		@options 		= o || {}
		@type			= o and o:type || 'var' # what about let here=
		@export			= no
		@references 	= [] # only needed when profiling
		@assignments 	= []
		self

	def closure
		@scope.closure

	def assignments
		@assignments

	# Here we can collect lots of type-info about variables
	# and show warnings / give advice if variables are ambiguous etc
	def assigned val, source
		@assignments.push(val)
		if val isa Arr
			# just for testing really
			@isArray = yes
		else
			@isArray = no
		self
	

	def resolve scope = scope, force = no
		return self if @resolved and !force
		

		@resolved = yes
		var es5 = STACK.es5
		var closure = @scope.closure
		var item = @shadowing or scope.lookup(@name)
		
		# console.log "resolving var {@name} {scope}",scope == @closure,@virtual

		# if this is a let-definition inside a virtual scope we do need
		#
		if @scope != closure and @type == 'let' and (es5 or @virtual) # or if it is a system-variable
			item = closure.lookup(@name)
			# console.log "resolving let {@name} {item.scope != scope}"
			# we now need to ensure that this variable is unique inside
			# the whole closure.
			scope = closure

		if item == self
			scope.varmap[@name] = self
			return self

		elif item
			# possibly redefine this inside, use it only in this scope
			# if the item is defined in an outer scope - we reserve the
			if item.scope != scope && (options:let or @type == 'let')
				scope.varmap[@name] = self
				# if we allow native let we dont need to rewrite scope?
				return self if (!es5 and !@virtual and !@shadowing)
					

			# different rules for different variables?
			if @options:proxy
				yes
			else
				var i = 0
				var orig = @name
				# it is the closure that we should use
				while scope.lookup(@name)
					@name = "{orig}{i += 1}"

		scope.varmap[@name] = self
		closure.varmap[@name] = self
		return self

	def reference
		self

	def node
		self

	def cache
		self

	def traverse
		self

	def free ref
		@declarator = null
		self

	def reuse ref
		@declarator = ref
		self

	def proxy par, index
		@proxy = [par,index]
		self

	def refcount
		@references:length

	def c
		return @c if @c
		# options - proxy??
		if @proxy
			@c = @proxy[0].c
			if @proxy[1]
				@c += '[' + @proxy[1].c + ']'
		else
			resolve unless @resolved
			var v = (alias or name)
			@c = typeof v == 'string' ? v : v.c
			# allow certain reserved words
			# should warn on others though (!!!)
			# if @c == 'new'
			# 	@c = '_new'
			# 	# should happen at earlier stage to
			# 	# get around naming conventions
			@c = "{c}$" if RESERVED_REGEX.test(@c) # @c.match(/^(default)$/)
			# @c = @c + '/*' + @ref + '*/'
		return @c

	def js
		self.c()

	# variables should probably inherit from node(!)
	def consume node
		return self

	# this should only generate the accessors - not dael with references
	def accessor ref
		var node = LocalVarAccess.new(".",null,self)
		# this is just wrong .. should not be a regular accessor
		# @references.push([ref,el]) if ref # weird temp format
		return node

	def assignment val
		Assign.new('=',self,val)

	def addReference ref
		if ref isa Identifier
			ref.references(self)

		if ref:region and ref.region
			@references.push(ref)
			if ref.scope__ != @scope
				@noproxy = yes

		self

	def autodeclare
		return self if @declared
		@autodeclare = yes
		scope.autodeclare(self)
		@declared = yes
		self

	def predeclared
		@declared = yes
		self


	def toString
		String(name)

	def dump typ
		var name = name
		return null if name[0].match(/[A-Z]/)

		return {
			type: type
			name: name
			refs: AST.dump(@references, typ)
		}


export class SystemVariable < Variable

	def pool
		@options:pool

	# weird name for this
	def predeclared
		scope.vars.remove(self)
		self

	def resolve
		return self if @resolved
		@resolved = yes

		# unless @name
		# adds a very random initial name
		# the auto-magical goes last, or at least, possibly reuse other names
		# "${Math.floor(Math.random * 1000)}"
		var alias = @name
		var typ = @options:pool
		var names = [].concat(@options:names)
		var alt = null
		var node = null

		@name = null

		var scope = self.scope

		if typ == 'tag'
			var i = 0
			while !@name
				var alt = "t{i++}"
				@name = alt unless scope.lookup(alt)

		elif typ == 'iter'
			names = ['ary__','ary_','coll','array','items','ary']

		elif typ == 'dict'
			names = ['dict']

		elif typ == 'val'
			names = ['v_']

		elif typ == 'arguments'
			names = ['$_','$0']

		elif typ == 'keypars'
			names = ['opts','options','pars']

		elif typ == 'counter'
			names = ['i__','i_','k','j','i']

		elif typ == 'len'
			names = ['len__','len_','len']

		elif typ == 'list'
			names = ['tmplist_','tmplist','tmp']
		# or if type placeholder / cacher (add 0)

		if alias
			names.push(alias)

		while !@name && alt = names.pop
			let foundAlt = scope.lookup(alt)
			# check if higher level?
			if !foundAlt # or (foundAlt.scope != scope and type == 'let' and !STACK.es5)
				@name = alt # unless scope.lookup(alt)

		if !@name and @declarator
			if node = declarator.node
				if var nodealias = node.alias
					names.push(nodealias + "_")

		while !@name && alt = names.pop
			@name = alt unless scope.lookup(alt)

		# go through alias proxies
		if alias and !@name
			var i = 0
			@name = alias
			# it is the closure that we should use
			while scope.lookup(@name)
				@name = "{alias}{i += 1}"

		@name ||= "${scope.counter += 1}"
		
		scope.varmap[@name] = self

		if type != 'let' or STACK.es5 or @virtual
			closure.varmap[@name] = self
		self

	def name
		resolve
		@name


export class ScopeContext < Node

	prop scope
	prop value
	prop reference

	def initialize scope, value
		@scope = scope
		@value = value
		@reference = null
		self

	def namepath
		@scope.namepath

	# instead of all these references we should probably
	# just register when it is accessed / looked up from
	# a deeper function-scope, and when it is, we should
	# register the variable in scope, and then start to
	# use that for further references. Might clean things
	# up for the cases where we have yet to decide the
	# name of the variable etc?

	def reference
		# if we are in  constructor we do want to declare it after super
		@reference ||= scope.declare("self",This.new) # {@scope.@level}_

	def fromScope other
		IndirectScopeContext.new(other,self)

	def c
		var val = @value # || @reference
		(val ? val.c : "this")

	def cache
		self
		
	def proto
		"{self.c}.prototype"

export class IndirectScopeContext < ScopeContext
	
	def initialize scope, parent
		@scope = scope
		@parent = parent
		@reference = parent.reference

	def reference
		@reference # parent.reference

	def c
		reference.c


export class RootScopeContext < ScopeContext

	def reference
		# should be a 
		@reference ||= scope.declare("self",scope.object, type: 'global')

	def c o
		# @reference ||= scope.declare("self",scope.object, type: 'global')
		# return "" if o and o:explicit
		var val = reference # @value || @reference
		return (val and val != this) ? val.c : "this"
		# should be the other way around, no?
		# o and o:explicit ? super : ""

export class Super < Node
	def initialize keyword
		@keyword = keyword
		super

	def visit
		@method = STACK.method
		@up = STACK.parent
		if var m = STACK.method
			m.set(supr: {node: STACK.blockpart, block: STACK.block})
			m.set(injectInitAfter: STACK.blockpart)
		self

	def startLoc
		@keyword and @keyword.startLoc

	def endLoc
		@keyword and @keyword.endLoc

	def c
		let m = @method
		let up = @up
		let sup = LIT('super')
		let op
		let virtual = m and m.option('inExtension')
		# need to know if our method is in the initial declaration

		# when super is written all by itself - it means to do the default action
		unless (up isa Access) or (up isa Call)
			if m and m.isConstructor
				op = LIT('super(...arguments)')
			elif m and virtual
				op = CALL(OP('.',slf,'super$'),[m.name.toStr])
				if m.isSetter
					op = CALL(OP('.',slf,'super$set'),[m.name.toStr,m.params.at(0)])
				elif !m.isGetter
					op = CALL(OP('.',op,'apply'),[slf,LIT('arguments')])
			elif m
				op = OP('.',sup,m.name)
				if m.isSetter
					op = OP('=',op,m.params.at(0))
				elif !m.isGetter
					op = CALL(op,[LIT('...arguments')])

			return op ? (M op.c(mark: false), self) : '/**/'

		if up isa Call and m and !m.isConstructor
			return OP('.',sup,m.name).c

		return "super"

# constants

export var BR = Newline.new('\n')
export var BR2 = Newline.new('\n\n')
export var SELF = Self.new
export var THIS = LIT('this')
export var PROTO = LIT('this.prototype')
# export var SUPER = Super.new

export var TRUE = True.new('true')
export var FALSE = False.new('false')
export var UNDEFINED = Undefined.new
export var NIL = Nil.new

export var ARGUMENTS = ArgsReference.new('arguments')
export var EMPTY = ''
export var NULL = 'null'

export var RESERVED = ['default','native','enum','with']
export var RESERVED_REGEX = /^(default|native|enum|with|new|char)$/










